"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8220],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return f}});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),u=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=u(e.components);return r.createElement(s.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),d=u(t),f=i,y=d["".concat(s,".").concat(f)]||d[f]||l[f]||o;return t?r.createElement(y,a(a({ref:n},p),{},{components:t})):r.createElement(y,a({ref:n},p))}));function f(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=d;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:i,a[1]=c;for(var u=2;u<o;u++)a[u]=t[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},86951:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return p}});var r=t(87462),i=t(63366),o=(t(67294),t(3905)),a=["components"],c={title:"Prolonged Background Sync",sidebar_position:5},s=void 0,u={unversionedId:"quick-tips/prolonged-background-sync",id:"quick-tips/prolonged-background-sync",isDocsHomePage:!1,title:"Prolonged Background Sync",description:"iOS apps will stop Ditto's sync protocol when the application is put into the",source:"@site/docs/ios/quick-tips/prolonged-background-sync.md",sourceDirName:"quick-tips",slug:"/quick-tips/prolonged-background-sync",permalink:"/ios/quick-tips/prolonged-background-sync",editUrl:"https://github.com/getditto/docs/tree/main/docs/ios/quick-tips/prolonged-background-sync.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Prolonged Background Sync",sidebar_position:5},sidebar:"docs",previous:{title:"Animating UITableView with the Observe API",permalink:"/ios/quick-tips/uitableview-animations-with-observe"},next:{title:"Avoiding Excessive Memory Consumption",permalink:"/ios/quick-tips/avoiding-excessive-memory-consumption"}},p=[],l={toc:p};function d(e){var n=e.components,t=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"iOS apps will stop Ditto's sync protocol when the application is put into the\nbackground. If you need Ditto to continue syncronizing while the application is\nin the background, you need to tell iOS to keep the app active. To do this, we\nrecommend playing silent music in the background."),(0,o.kt)("p",null,"Create an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"BackgroundSync")," on your main controller and call\n",(0,o.kt)("inlineCode",{parentName:"p"},"BackgroundSync.shared.start()"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},'final public class BackgroundSync {\n    public static let shared = BackgroundSync()\n    private let player: AVAudioPlayer\n    private let base64AudioString = "UklGRiYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQIAAAD8/w=="\n\n    public var isOn = false\n\n    private init() {\n        let audioData = Data(base64Encoded: base64AudioString)!\n        try! AVAudioSession.sharedInstance().setCategory(AVAudioSession.Category.playback,\n                                                         mode: .default,\n                                                         options: .mixWithOthers)\n        try! AVAudioSession.sharedInstance().setActive(true)\n        player = try! AVAudioPlayer(data: audioData, fileTypeHint: "wav")\n        player.numberOfLoops = -1\n        player.volume = 0.01\n        player.prepareToPlay()\n    }\n\n    public func start() {\n        guard isOn else { return }\n\n        NotificationCenter.default.addObserver(self, selector: #selector(interuptedAudio), name: AVAudioSession.interruptionNotification, object: AVAudioSession.sharedInstance())\n        self.player.play()\n        print("BackgroundSync started")\n    }\n\n    public func stop() {\n        NotificationCenter.default.removeObserver(self, name: AVAudioSession.interruptionNotification, object: nil)\n        if player.isPlaying {\n            player.stop()\n            print("BackgroundSync stopped")\n        }\n    }\n\n    @objc private func interuptedAudio(_ notification: Notification) {\n        if notification.name == AVAudioSession.interruptionNotification && notification.userInfo != nil {\n            let info = notification.userInfo!\n            var intValue = 0\n            (info[AVAudioSessionInterruptionTypeKey]! as AnyObject).getValue(&intValue)\n            if intValue == 1 { self.player.play() }\n        }\n    }\n}\n')))}d.isMDXComponent=!0}}]);