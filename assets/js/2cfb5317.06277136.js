"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7126],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=c(n),h=a,d=m["".concat(s,".").concat(h)]||m[h]||u[h]||r;return n?i.createElement(d,l(l({ref:t},p),{},{components:n})):i.createElement(d,l({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var c=2;c<r;c++)l[c]=n[c];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},99492:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return p}});var i=n(87462),a=n(63366),r=(n(67294),n(3905)),l=["components"],o={title:"Preventing Accumulating Combine Publishers",sidebar_position:6},s=void 0,c={unversionedId:"quick-tips/prevent-accumulating-publishers",id:"quick-tips/prevent-accumulating-publishers",isDocsHomePage:!1,title:"Preventing Accumulating Combine Publishers",description:"Note: This is a general concept that isn't specific to Ditto, but really towards all applications that might use Combine or RxSwift.",source:"@site/docs/ios/quick-tips/prevent-accumulating-publishers.md",sourceDirName:"quick-tips",slug:"/quick-tips/prevent-accumulating-publishers",permalink:"/ios/quick-tips/prevent-accumulating-publishers",editUrl:"https://github.com/getditto/docs/tree/main/docs/ios/quick-tips/prevent-accumulating-publishers.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Preventing Accumulating Combine Publishers",sidebar_position:6},sidebar:"docs",previous:{title:"Prolonged Background Sync",permalink:"/ios/quick-tips/prolonged-background-sync"},next:{title:"Avoiding Excessive Memory Consumption",permalink:"/ios/quick-tips/avoiding-excessive-memory-consumption"}},p=[{value:"Creating a memory leak with Combine",id:"creating-a-memory-leak-with-combine",children:[{value:"A hacky fix",id:"a-hacky-fix",children:[],level:3}],level:2},{value:"The Good way!",id:"the-good-way",children:[],level:2}],u={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,l);return(0,r.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note: This is a general concept that isn't specific to Ditto, but really towards all applications that might use Combine or RxSwift.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/getditto/samples/tree/master/combine-switchtolatest"},"For the full source code visit the GitHub Sample here")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.loom.com/share/40e110dfecf54fcbbeb6c4e69537c055"},"Video demonstration of the issue and solution"))),(0,r.kt)("p",null,"A common issue we see in reactive apps is a failure to dispose of resources as conditions change. Perhaps your app sees a large accumulation of publishers that infinitely grow. Let's take a look at this common pitfall in a simple example. "),(0,r.kt)("p",null,"Let's say we have a collection of flights and each document has a structure like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'[\n  {\n    "_id": "123abc",\n    "carrier": "BA",\n    "number": 45,\n    "from": "SFO",\n    "to": "LHR"\n  },\n  {\n    "_id": "456284a",\n    "carrier": "BA",\n    "number": 8942,\n    "from": "SFO",\n    "to": "LHR"\n  },\n  {\n    "_id": "8sd24s",\n    "carrier": "LH",\n    "number": 8942,\n    "from": "JFK",\n    "to": "FRA"\n  }\n  {\n    "_id": "79542",\n    "carrier": "UA",\n    "number": 1234,\n    "from": "ORD",\n    "to": "MIA"\n  }\n  // etc...\n]\n')),(0,r.kt)("h2",{id:"creating-a-memory-leak-with-combine"},"Creating a memory leak with Combine"),(0,r.kt)("p",null,"Now our application code has a ",(0,r.kt)("inlineCode",{parentName:"p"},"ViewModel")," that creates a live queries based off a change of the ",(0,r.kt)("inlineCode",{parentName:"p"},"carrier")," property. Each time the carrier changes, we register a new ",(0,r.kt)("inlineCode",{parentName:"p"},"liveQueryPublisher")," with the ",(0,r.kt)("inlineCode",{parentName:"p"},'args: ["carrier": carrier]')," query argument. Like all good Combine best practices, we store the publisher references in a ",(0,r.kt)("inlineCode",{parentName:"p"},"var cancellables = Set<AnyCancellables>()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'import DittoSwift\nimport Combine\nimport SwiftUI\n\nclass ViewModel: ObservableObject {\n  \n  @Published var flights: [Flight] = []\n  @Published var carrier: String = "BA"\n  \n  var cancellables = Set<AnyCancellables>()\n  \n  init() {\n    $carrier.sink { carrier in\n            DittoManager.shared.ditto.store.collection("flights")\n                .find("carrier == $args.carrier", args: ["carrier": carrier])\n                .liveQueryPublisher()\n                .sink { (docs, _) in\n                    self.flights = docs.map({ try! $0.typed(as: Flight.self).value })\n                }\n                .store(in: &self.cancellables)\n        }\n        .store(in: &cancellables)\n  }\n}\n')),(0,r.kt)("p",null,"Here's our problem, each time we change the ",(0,r.kt)("inlineCode",{parentName:"p"},"carrier")," to a new value, you will notice that your app's memory usage will gradually rise. It will be even worse if new documents change while this happens. Why is this?"),(0,r.kt)("p",null,"Our app is to filter the ",(0,r.kt)("inlineCode",{parentName:"p"}," @Published var flights: [Flight]")," variable to match the current ",(0,r.kt)("inlineCode",{parentName:"p"},"carrier"),". However, each time the carrier changes, ",(0,r.kt)("strong",{parentName:"p"},"we are registering a new ",(0,r.kt)("inlineCode",{parentName:"strong"},"liveQueryPublisher")," without disposing the previous live query"),"! There lies the root cause of the accumulation of publishers. "),(0,r.kt)("h3",{id:"a-hacky-fix"},"A hacky fix"),(0,r.kt)("p",null,"A hacky way to fix this is by storing the ",(0,r.kt)("inlineCode",{parentName:"p"},"liveQueryPublisher()")," into another set of cancellables and dispose of them whenever the carrier changes. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'import DittoSwift\nimport Combine\nimport SwiftUI\n\nclass ViewModel: ObservableObject {\n  \n  @Published var flights: [Flight] = []\n  @Published var carrier: String = "BA"\n  \n  var cancellables = Set<AnyCancellables>()\n  // this was added\n  var liveQueryCancellables = Set<AnyCancellables>()\n  \n  init() {\n    $carrier.sink { carrier in\n            // cancel all the live queries when this value changes. \n            liveQueryCancellables.removeAll()\n            DittoManager.shared.ditto.store.collection("flights")\n                .find("carrier == $args.carrier", args: ["carrier": carrier])\n                .liveQueryPublisher()\n                .sink { (docs, _) in\n                    self.flights = docs.map({ try! $0.typed(as: Flight.self).value })\n                }\n                .store(in: &self.liveQueryCancellables) // store it in another set of cancellables\n        }\n        .store(in: &cancellables)\n  }\n}\n')),(0,r.kt)("p",null,"Hooray! This solves the problem! You'll notice that there is now only ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," live query regardless of the ",(0,r.kt)("inlineCode",{parentName:"p"},"carrier")," changes. However, this has made the application more complex and hard to read, as every ",(0,r.kt)("inlineCode",{parentName:"p"},"sink")," requires managing cancellable states. If you add more live queries this gets complicated quite fast. "),(0,r.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("h3",{parentName:"div",id:"key-takeaway"},"Key Takeaway"),(0,r.kt)("p",{parentName:"div"},"Do not put a ",(0,r.kt)("inlineCode",{parentName:"p"},".sink")," within ",(0,r.kt)("inlineCode",{parentName:"p"},".sink"),". This is almost always an anti-pattern that will cause a lot of headache. "))),(0,r.kt)("h2",{id:"the-good-way"},"The Good way!"),(0,r.kt)("p",null,"How do we maintain only 1 liveQueryPublisher even if the carrier changes in the most clean Combine-friendly way? Let's see:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'class SolutionViewModel: ObservableObject {\n\n    @Published var carrier: String = DittoManager.carriers.randomElement()!\n    @Published var flights: [Flight] = []\n\n    var cancellables = Set<AnyCancellable>()\n\n    init() {\n\n        $carrier\n            .removeDuplicates() // 1. \n            .map({ carrier in // 2.\n                return DittoManager.shared.ditto.store.collection("flights")\n                    .find("carrier == $args.carrier", args: ["carrier": carrier])\n                    .liveQueryPublisher()\n            })\n            .switchToLatest() // 3.\n            .map({ (docs, _) in // 4.\n                return docs.map({ try! $0.typed(as: Flight.self).value })\n            })\n            .assign(to: \\.flights, on: self) // 5. \n            .store(in: &cancellables) // 6. \n        \n    }\n}\n')),(0,r.kt)("p",null,"Let's review what we did (see the code comments for the correlated bullet numbers):"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"We observe the carrier, but only if the values change by using ",(0,r.kt)("inlineCode",{parentName:"li"},"removeDuplicates()"),". This means if the carrier value goes from ",(0,r.kt)("inlineCode",{parentName:"li"},"AS")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"AS"),", it is fired only once. But if the value goes from ",(0,r.kt)("inlineCode",{parentName:"li"},"AS")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"LH")," it's fired twice. It will compare the new and the old value and emit once the values are different. "),(0,r.kt)("li",{parentName:"ol"},"Once we get the ",(0,r.kt)("inlineCode",{parentName:"li"},"carrier"),", we ",(0,r.kt)("inlineCode",{parentName:"li"},".map")," it to a ",(0,r.kt)("inlineCode",{parentName:"li"},"liveQueryPublisher")," while feeding in the query arguments. Note that this ",(0,r.kt)("inlineCode",{parentName:"li"},".map")," isn't returning documents, but a ",(0,r.kt)("inlineCode",{parentName:"li"},"Publisher"),". This key is difference is important in step 3. "),(0,r.kt)("li",{parentName:"ol"},"The next operator is the most critical, we add a ",(0,r.kt)("inlineCode",{parentName:"li"},"switchToLatest()"),". This operator will switch the chain of operators to the latest publisher (from the last ",(0,r.kt)("inlineCode",{parentName:"li"},".map"),"). ",(0,r.kt)("em",{parentName:"li"},"Any previous publisher will be disposed or canceled!"),". This is the operator that does all the work! "),(0,r.kt)("li",{parentName:"ol"},"We can now ",(0,r.kt)("inlineCode",{parentName:"li"},".map")," the ",(0,r.kt)("inlineCode",{parentName:"li"},"docs")," results of the ",(0,r.kt)("inlineCode",{parentName:"li"},"liveQueryPublisher")," and decode them to our ",(0,r.kt)("inlineCode",{parentName:"li"},"Flight")," codable. "),(0,r.kt)("li",{parentName:"ol"},"Instead of using ",(0,r.kt)("inlineCode",{parentName:"li"},".sink"),", we ",(0,r.kt)("inlineCode",{parentName:"li"},".assign")," the ",(0,r.kt)("inlineCode",{parentName:"li"},"flights: [Flight]")," to the ",(0,r.kt)("inlineCode",{parentName:"li"},"self.flights")," variable. "),(0,r.kt)("li",{parentName:"ol"},"Finally, we store the entire chain of commands as ",(0,r.kt)("em",{parentName:"li"},"a single publisher in a single ",(0,r.kt)("inlineCode",{parentName:"em"},"Set<AnyCancellable>()")),"! ")),(0,r.kt)("p",null,"The summary:"),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},".map")," to return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Publisher")," and follow it immediately with ",(0,r.kt)("inlineCode",{parentName:"p"},"switchToLatest()")," to ensure the publishers do not accumulate and that only one is registered down the chain of operators. Using both is not only helpful with Ditto-based applications, but also any application that uses Combine. This will prevent quite a lot of memory leaks in the future. "),(0,r.kt)("p",null,"If you are familiar with ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ReactiveX/RxSwift"},"RxSwift"),", ",(0,r.kt)("inlineCode",{parentName:"p"},".map")," + ",(0,r.kt)("inlineCode",{parentName:"p"},"switchToLatest")," is the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"flatMapLatest"),"."))}m.isMDXComponent=!0}}]);