---
title: 'Using Ditto with Codable Support'
sidebar_position: 1
---

By default `DittoSwift` adds support for Foundaton Framework's [`Codable`](https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types) types. This means that it's extremely easy to use static typed structs and classes to serialize and deserialized `DittoDocument` types in your Swift application.

For example, let's say we have a `Car` struct that represents a `DittoDocument` in the `cars` collection. First, ensure that the `struct Car` adheres to `Codable`. Then add your properties that you know you'll use throughout your application.

```swift title=Car.swift
import Foundation

struct Car: Codable {
  var _id: String
  var name: String
  var mileage: Double
  var tags: [String]
}
```

### Decoding `DittoDocument` into `Codable`

Both `DittoDocument` and `DittoMutableDocument` types can be decoded to a `Codable` type using the: `typed(as: Codable.self).value`. This method _can throw an error_ if decoding failed for some reason. 

```swift
let documents: [DittoDocument] = ditto.store["cars"].findAll().exec()
do {
  let cars: [Car] = try collection.findAll().exec().map({ try $0.typed(as: Car.self).value })
} catch(let err) {
  print(err.localizedDescription)
}
```

### Inserting a `DittoDocument` via `Codable`

Once your `Car: Codable` type is defined, you can construct an instance an `insert` the document value 

```swift
let car = Car(_id: "123abc", name: "Ford", mileage: 45000, tags: ["A", "B", "C"])
let insertedId = try! ditto.store["cars"].insert(car)
print(insertedId.value) // "616f529700a262fb00b88425"

// We can retrieve our car object by decoding it with `.typed`
let foundCar: Car? = try! collection.findByID(insertedId).exec()?.typed(as: Car.self).value
```

### Inserting a Document via `Codable` with an autogenerated `_id`

If you want to rely on `Ditto` to generate an `_id`, ensure that your `Codable` type as `String!` type for the `_id` variable:

```swift
import Foundation

struct Car: Codable {
  var _id: String! // or you can use String? 
  var name: String
  var mileage: Double
  var tags: [String]
}
```

Now you can insert a document by omitting the `_id` parameter while filling out the other properties:

```swift
let car = Car(name: "Ford", mileage: 45000, tags: ["A", "B", "C"])
let insertedId = try! ditto.store["cars"].insert(car)
print(insertedId.value) // "616f529700a262fb00b88425"
```

### Inserting a Document with a `Codable` `_id` property (composite key)

The great thing about Ditto's `Codable` support is that we get composite keys support out of the box. Composite keys are `_id` types which have multiple values that define it's uniqueness. For example let's say we have a `OrderLineItem: Codable`. This represents a line item in a receipt. It's uniqueness of an `OrderLineItem` is on a specific `orderId: String` and a specific `productId: String`. 

We can now define our structs:

```swift
struct OrderLineItem: Codable {
  
  struct OrderLineItemId: Codable {
    var orderId: String
    var productId: Int
  }
  
  var _id: OrderLineItemId
  var quantity: Int
  var price: Double
}
```

Now you can insert a document with your strongly typed structs:

```swift
let _id = OrderLineItem.OrderLineItemId(orderId: "456abc", productId: 56)
let orderLineItem = OrderLineItem(_id: _id, quantity: 5, price: 12)
try! ditto.store["orderLineItems"].insert(orderLineItem)
```


### Querying with `Codable` query parameters (`findByID` and `find`)

`Codable` support also exists in our `findByID` and `find` APIs.

Like our example above, you can pass in an `OrderLineItemId: Codable` to `findByID`

```swift
let _id = OrderLineItem.OrderLineItemId(orderId: "456abc", productId: 56)
let orderLineItem: OrderLineItem? = ditto.store["orderLineItems"].findByID(_id).exec()
```

In version v1.0.14, we've also added support for `Codable` in the `find(args:)` parameter:

```swift
let _idA = OrderLineItem.OrderLineItemId(orderId: "456abc", productId: 56)
let _idB = OrderLineItem.OrderLineItemId(orderId: "456abc", productId: 56)
ditto.store["orderLineItems"].find("contains(args._ids, _id)", args: [
  "_ids": [_idA, _idB]
])
``` 

### Updating 

We have yet to add the ability to update a document via a `Codable` type. For now your application must use the standard `.update` APIs like so:

```swift
ditto.store["cars"].findByID("123abc").update({ mutableDoc in 
   mutableDoc?["mileage"] = 6000
})
```

### Deleting and Evicting

Since querying with codables is supported, delete and eviction support comes for free. 

```swift
let _id = OrderLineItem.OrderLineItemId(orderId: "456abc", productId: 56)
ditto.store["orderLineItems"].findByID(_id).remove()
// or 
ditto.store["orderLineItems"].findByID(_id).evict()
```

<!-- ## Dealing with mismatched, missing, or defaulting to certain values.

Since Ditto is an eventually consistent database, keys may or may not exist since multiple peers can edit the data over the lifetime of a Document's existence. This can cause problems with decoding values. 

For example it's very possible that __peer A creates a document like so:__

```swift title=Peer A insertion
ditto.store["cars"].insert([
  "_id": "123abc",
  "name": "Honda",
  "mileage": 4500,
  "tags": ["a", "z", "g"]
])
```

And __peer B creates a document without the mileage key:__

```swift title=Peer B insertion
ditto.store["cars"].insert([
  "_id": "123abc",
  "name": "Honda",
  "tags": ["a", "z", "g"]
])
``` -->

