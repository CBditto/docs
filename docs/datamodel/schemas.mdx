---
title: 'Schemas'
sidebar_position: 6
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import SnippetGroup from '@site/src/components/SnippetGroup';

Ditto's replication protocol is backwards-compatible and reliable. This means
that eventually you will have the *"couch device problem"* (i.e., a device that
fell behind a couch). In other words, a device in your mesh may be offline for a
significant amount of time before connecting back with other devices. 

If the shape of your documents are significantly different on that device, there
could be documents that do not conform with your new application code.
Syncronizing with this "couch device" could cause other devices to crash
unexpectedly in production.

## When do I version my documents?

Changing your schema is inevitable. To ensure reliability over time, you
should create your own schema versioning pattern for each Ditto document. Many
developers use typed structs, Codable (Swift) or TypeScript (JavaScript) to
ensure that all documents are added and retrieved from their database in a
predictable fashion. You can use these types to detect older or incompatible versions before rendering them in your UI.

### Backwards-compatibility

Older data could be very important, or it could not be. It's your choice to
decide what to do with these old documents: you could accept (as-is), reject
(ignore), or migrate them to the new schema.

For example, here's a breaking version change where we add a new field and
change the type of an old field:

**App version 2**

```swift
private struct V1Car {
    let _id: String
    let make: String
    let model: String
    let year: String
    var version: Int
}

private struct V2Car {
    let _id: String
    let make: String
    let model: String
    let year: Int
    let hometown: String
    var version: Int
}

func decode(car: DittoDocument) -> V2Car {
  switch(car.version) {
    case 1 {
      let oldCar = try person.typed(as: V1Car.self).value
      let migratedCar = V2Car()
      migratedCar.make = oldCar.make
      migratedCar.model = oldCar.model
      migratedCar.year = Int(oldCar.year)
      migratedCar.version = 2
      migratedCar.hometown = "N/A"
      return migratedCar
    }
    case 2 {
      return try person.typed(as: V2Car.self).value
    }
  }
}
```

**App version 1**

You also may want to ignore documents that come from incompatible applications.

```swift
private struct V1Car {
    let _id: String
    let make: String
    let model: String
    let year: String
    var version: Int
}

func decode(car: DittoDocument) -> V1Car {
  switch(car.version) {
    case 1 :
      let oldCar = try person.typed(as: V1Car.self).value
      return oldCar
    default:
      // create default car item, or ignore document altogether
      return
  }
}
```


### Supporting the latest version

When a new application version is detected, you can stop syncronizing. You can detect that a new application version is available by querying for a
`_schemaVersion` that is greater than the current version. If a new version is
detected, stop sync and tell the user they need to upgrade their app to the
latest version. 

```js
const query = '_schemaVersion > 1'
collection.find(query).observe(() => {
  // Notify user to update to latest application version.
  ditto.stopSync()
})
```

This is a common pattern that many applications use. For example, Apple Notes
warns users that they are on an older version and will experience degraded
features until they upgrade.

### Supporting the same version

You could also only synchronize documents that come from schema versions
that are the same as your current schema version.  

```js
const query = 'name == $args.name && age <= $args.age && _schemaVersion == 1'
collection.find(query, () => {
  age: 32,
  name: 'Max',
})
```
