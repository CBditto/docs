---
title: 'Online With Authentication'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Overview

The "Online With Authentication" identity type is geared towards apps will be deployed in real world settings. "Online With Authentication" identity types are: 

* for apps that need to integrate with existing permissions
* for apps that need to integrate with existing authentication systems

:::info
* __This section will require knowledge of writing server side HTTP endpoints and handlers.__ The server side sample codes are written in JavaScript (NodeJS with an [Express](https://expressjs.com/)-like API), however you can use any framework or language of your choosing.
* The Ditto platform __does not come with an identity provider__. Using "Online With Authentication" requires that that you have your own identity provider already set up. Each app can use multiple identity providers. Identity providers can be:
  * Your own service
  * Facebook, Twitter, GitHub, etc...
  * Okta, Auth0, Stytch, etc...
:::


## Configure your Authentication Webhook Endpoint

The authentication webhook needs to handle an __HTTP POST__ request. Each client that will need to authenticate will send a payload to this webhook. 

### Incoming POST body

Your webhook should be prepared for a JSON body like this:

```jsonc 
{
  "appID": "ce914163-2df7-4985-9821-7034891cdcda", // the appID
  "provider": "my-auth", // this is the "Name" of the "Authentication Webhook"
  "token": "eyJhbGciOiJI..." // this is what each device will send to authenticate
}
```

Your can introspect these values by parsing out the request body:

```js
server.post('/', (req, res) => {
  const appID = req.body.appID
  const provider = req.body.provider
  const token = req.body.token
})

```

### Rejecting a user

To reject a user respond with a JSON payload below. You do not need to manipulate the HTTP response status.

```jsonc
{
  "authenticate": false
}
```

In the server your code may look similar to:

```js
server.post('/', (req, res) => {
  res.json({
    "authenticate": false
  })
})
```

Generally, you will want to check the token for some sort of validity. Let's assume you have some sort of library or logic to parse and validate the token is for a specific user. You can use the `userInfo` key in your JSON response to pass information back to client.

```js
server.post('/', async (req, res) => {
  const token = req.body.token;
  try {
    const { userId } = await checkToken(token)
    // omitted for brevity
  } catch (err) {
    res.json({
      "authenticate": err,
      "userInfo": err.message
    }) 
  }
})
```


### Accepting a user

To accept a user, the JSON payload needs to contain information about:

* `authenticate` to `true` to tell the webhook that the user has successfully validated
* `expirationSeconds` is `number` property on how long the authentication session is valid for before a refresh is required.
* `userID` is a `string` which identifies the the `userID`. This should be _unique_ across users within your app
* `permissions` which describes all the types of access control for collections and documents that this user can `read` or `write`

```jsonc
{
  "authenticate": true,
  "expirationSeconds": 28800,
  "userID": "123abc",
  "permissions": {
    "read": {
      "everything": false,
      "queriesByCollection": {
        "books": [
          "endsWith(_id, 'Potter')"
        ],
        "my_collection": [
          "_id == 'my-specific-id'",
          "_id == 'id1' || _id == 'id2'"
        ],
        "my_favorite_integers": [
          "_id > 100",
          "_id > -10 && _id < 10"
        ],
        "test": [
          "true"
        ],
        "weird_bools_collection": [
          "_id == false"
        ]
      }
    },
    "write": {
      "everything": false,
      "queriesByCollection": {
        "__auth_config": [
          "true"
        ],
        "boats": [
          "regex(_id, '^Wave.*')"
        ],
        "test": [
          "true"
        ]
      }
    }
  }
}
```

Finally, deploy this application to a server that can be accessible by Ditto's cloud platform. __You will need the URL in the next section.__

## Configure your Portal App

To use an "Online With Authentication" identity, go to your app in the [portal](https://portal.ditto.live/) and find the __Authentication Mode & Webhook Settings__ section. Ensure that __"With Authentication"__ is selected like so:

![Online With Authentication setting in Portal](./portal-with-authentication-setting.png)

Below, a section called __Authentication Webhooks__ will be editable. Once your Authentication Webhook Endpoint(s) is deployed and ready, you can register it in the portal. Add a __Name__ and __URL__. 

* The __Name__ is used the differentiate between multiple authentication. Most applications will have one authentication webhook, however the __Name__ parameter is still required. This name value is important for the next section.
* The __URL__ parameter is the fully qualified URL of the webhook that you deployed in the section above. Please include the protocol (_https:// or http://_ though we highly discourage _http://_). Please be sure that this endpoint is not behind a firewall or VPN. If you cannot get around this requirement [contact us](mailto:contact@ditto.live). 

![Sample Authentication Webhook Endpoint in the Portal](./sample-authentication-webhook-endpoint.png)

Click __Add__ to register the webhook in your portal app. Now client applications that need to authenticate will be able to use these endpoints.

## Configure your Client App

<Tabs
  groupId="programming-language"
  defaultValue="javascript"
  values={[
    {label: 'JavaScript', value: 'javascript'},
    {label: 'Swift', value: 'swift'},
    {label: 'Objective-C', value: 'objc'},
    {label: 'Kotlin', value: 'kotlin'},
    {label: 'Java', value: 'java'},
    {label: 'C#', value: 'csharp'},
    {label: 'C++', value: 'cpp'},
  ]
}>
<TabItem value="javascript">

```js
import { init, Ditto } from "@dittolive/ditto"
(async () => {
  await init() // you need to call this at least once before using any of the Ditto API
  const identity = { type: 'onlinePlayground', appID: 'REPLACE_ME_WITH_YOUR_APP_ID' }
  const ditto = new Ditto(identity, '/persistence/file/path')
  ditto.setLicenseToken("REPLACE_ME_WITH_YOUR_LICENSE_TOKEN")
  ditto.tryStartSync()
})()
```

</TabItem>
<TabItem value="swift">

```swift
let ditto = Ditto(identity: DittoIdentity.onlinePlayground(appID: "REPLACE_ME_WITH_YOUR_APP_ID"))
ditto.setLicenseToken("REPLACE_ME_WITH_YOUR_LICENSE_TOKEN")
try! ditto.tryStartSync()
```

</TabItem>
<TabItem value="objc">

```objc

DITIdentity *onlinePlaygroundIdentity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@"REPLACE_ME_WITH_YOUR_APP_ID"];
DITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];
[ditto setLicenseToken: @"REPLACE_ME_WITH_YOUR_LICENSE_TOKEN"];
NSError *error = nil;
[ditto tryStartSync:&error];
```

</TabItem>
<TabItem value="kotlin">

```kotlin
try {
  val androidDependencies = AndroidDittoDependencies(context)
  val identity = DittoIdentity.OnlinePlayground(androidDependencies, appID = "REPLACE_ME_WITH_YOUR_APP_ID")
  val ditto = Ditto(androidDependencies, identity)
  ditto.setLicenseToken("REPLACE_ME_WITH_YOUR_LICENSE_TOKEN")
} catch(e: RuntimeException) {
  Log.e("Ditto error", e.message!!)
}

```

</TabItem>
<TabItem value="java">

```java
DittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);
DittoIdentity identity = new DittoIdentity.OnlinePlayground(androidDependencies, "REPLACE_ME_WITH_YOUR_APP_ID");
Ditto ditto = new Ditto(androidDependencies);

try {
  ditto.setLicenseToken("REPLACE_ME_WITH_YOUR_LICENSE_TOKEN");  
  ditto.tryStartSync();
} catch(DittoError e) {
  Log.e("Ditto Error", e.getMessage())
}
```

</TabItem>
<TabItem value="csharp">

```csharp
```

</TabItem>
<TabItem value="cpp">

```cpp
```

</TabItem>
</Tabs>
