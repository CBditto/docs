---
title: 'Introduction'
sidebar_position: 1
---

The Ditto HTTP API follows a RESTful pattern and is organized into several resources. API Resources typically map to the key elements of the [Ditto Data Model](../common/concepts/overview). Applications may contain one or more `Collection`s of `Documents` or `TimeSeries` of `Event`s. JSON is used as the default representation for individual resources, and will be indicated by the `Content-Type` HTTP Header. Resources which are best represented by a sequence or stream of items are represented by [JSONlines](https://jsonlines.org), that is new line delimited JSON. This will be indicated by the MIME type `application/json-l`. UTF-8 encoding is used and required unless otherwise indicated. Binary data should be Base64 encoded. Where alternative representations are desired, the API Client may use the `Accept` HTTP Header to indicate this in the Request.

<!-- Currently, Collections and TimeSeries can't be edited directly as top level API resources; only operations on the underlying documents are supported. Collections and TimeSeries are created implicitly by inserting into them. Later, we may add the ability to create, configure, and delete entire collections and timeseries directly.-->
<!-- This document is intended to serve as a public facing guide to the entire HTTP API at the time we deliver Particle phase 1. Items for future work or discussion will be called out in comments like this. -->

## Endpoint

The Ditto HTTP API provides a programmatic interface for interactions with
Ditto-powered Apps which expose an HTTP Server Interface. A primary use case for
the HTTP API is external systems which integrate with `cloud.ditto.live`.

The canonical root URL for the HTTP API is `https://{app_id}.cloud.ditto.live/api/v2/`. The standard port 443 is used.

```bash
curl https://{app_id}.cloud.ditto.live/api/v2
```

For simple examples for using the HTTP API for document storage, see the
corresponding sections in the Concepts section for
[querying](./common/concepts/querying), [writing](./common/concepts/writing),
and [remove](./common/concepts/remove). 

Ditto Big Peer also provides HTTP APIs for querying timeseries data. See the
[timeseries section](./timeseries) for more information.

In addition to these examples, we also have JSON schema documents that help
describe the request bodies and responses. They can be helpful if you have any
questions on what any field means or what the server might return.

## Transactions

If successful, the response to POST or DELETE requests will include a
Transaction ID, which can be used on subsequent GET requests. This type of
insertion is non-blocking and so is very performant.

Each HTTP API write request represents a distinct transaction which may be one
or many operations (e.g., upsert or remove). Because Ditto is also a distributed
system, `Transaction ID`s are used to represent the order in which transactions
should be applied. Each write request returns it's associated `Transaction ID`. 

Find requests can optionally specify a Transaction ID, which will instruct the
server to wait until the given transaction is applied before executing the
query. The newly inserted events may still be replicating through the Ditto mesh
between the time of the write and the time of the find request. 

In each API Request a `Transaction ID` may optionally be provided in an HTTP
HEADER called `X-DITTO-TXN-ID` with an integer value, which represents this
request should be applied to the "version" of the data _at least_ as recent as
this value. If we don't supply this header, the default behavior is to use the
most recent version common to all Ditto nodes. Note also that if the Ditto node
servicing the Request can't supply the version of the data requested, an error
will be returned.

For example, you write data using the HTTP API and get back Transaction 17. If
you want to ensure that the values included in Transaction included in our
subsequent query, we would include the header `X-DITTO-TXN-ID: 17` in our
request. 

<!-- Current implementation requires an Actor ID however in the future only the Site ID will be needed. -->

## Remove Wins

Ditto uses "remove-wins" semantics, so in some situations the client may want to
force Ditto to first read its current data and ensure another peer hasn't issued
a concurrent DELETE request before attempting an insertion with a POST request.
To do this, the client provides the HTTP HEADER `X-DITTO-ENSURE-INSERT: true`.


## Errors

Ditto HTTP API errors are indicated with an HTTP Status Code and with a JSON response body containing an object with a single "error" key. This Error object contains the following fields:

- error.code - The HTTP Status Code for
- error.message - A short description of the error
- error.data - An optional object which contains further elaboration about the error

## Authorization

Access to the Ditto HTTP API is mediated by an `Authorization: Bearer` HTTP Header containing a valid, signed, JWT Token (RFC 7519). This token can be obtained from the following endpoint: `https://{app_id}.cloud.ditto.live/_ditto/auth/login`. See [Online With Authentication](/security/online-with-authentication) to secure your HTTP endpoint.

The JWT encodes the identity of the client, the target application, and the permissions the client is entitled to access.

## Generating an X-DITTO-CLIENT-ID

An `X-DITTO-CLIENT-ID` is required whenever issuing POST requests to the HTTP
API. You should generate one for each client, as this ID represents a client in
the Ditto mesh. Generating a new ID for each request could cause performance
issues. When possible generate this ID and cache it for the duration of the
client.

```python
>>> import base64
>>> site_id = 5
>>> epoch = 0
>>> site_id_bytes = site_id.to_bytes(8,'big')
>>> epoch_bytes = epoch.to_bytes(8, 'big')
>>> actor_id_bytes = site_id_bytes + epoch_bytes
>>> actor_id_bytes
b'\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00'
>>> base64.b64encode(actor_id_bytes)
b'AAAAAAAAAAUAAAAAAAAAAA=='
```
