"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3040],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),c=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(u.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},l=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,u=e.parentName,p=a(e,["components","mdxType","originalType","parentName"]),l=c(n),d=o,m=l["".concat(u,".").concat(d)]||l[d]||h[d]||i;return n?r.createElement(m,s(s({ref:t},p),{},{components:n})):r.createElement(m,s({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=l;var a={};for(var u in t)hasOwnProperty.call(t,u)&&(a[u]=t[u]);a.originalType=e,a.mdxType="string"==typeof e?e:o,s[1]=a;for(var c=2;c<i;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}l.displayName="MDXCreateElement"},9833:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return u},default:function(){return l},frontMatter:function(){return a},metadata:function(){return c},toc:function(){return p}});var r=n(87462),o=n(63366),i=(n(67294),n(3905)),s=["components"],a={title:"Transactions",sidebar_position:5},u=void 0,c={unversionedId:"guides/http/how-it-works",id:"guides/http/how-it-works",isDocsHomePage:!1,title:"Transactions",description:'Ditto uses transactions to group related operations together. Typically, each HTTP API Request represents a distinct transaction which may insert, update, or remove one or more documents. Because Ditto is also a distributed system, Transaction IDs are used to represent the order in which transactions should be applied. Thus queries also specify Transaction IDs, which represent the "version" of the data you wish to query. For example, if you insert some Events into a TimeSeries in Transaction 17 and then want to query that same TimeSeries. The newly inserted events may still be replicating through the Ditto mesh. Should these new events be returned in the query response? In other words, do the results of a query depend on whether or not the insertion is first applied? Transaction IDs help solve this problem.',source:"@site/docs/guides/http/how-it-works.md",sourceDirName:"guides/http",slug:"/guides/http/how-it-works",permalink:"/pr-preview/pr-225/guides/http/how-it-works",editUrl:"https://github.com/getditto/docs/edit/master/docs/guides/http/how-it-works.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Transactions",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Timeseries",permalink:"/pr-preview/pr-225/guides/http/timeseries"},next:{title:"Intro",permalink:"/pr-preview/pr-225/concepts/security"}},p=[],h={toc:p};function l(e){var t=e.components,n=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Ditto uses transactions to group related operations together. Typically, each HTTP API Request represents a distinct transaction which may insert, update, or remove one or more documents. Because Ditto is also a distributed system, ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction ID"),'s are used to represent the order in which transactions should be applied. Thus queries also specify Transaction IDs, which represent the "version" of the data you wish to query. For example, if you insert some Events into a TimeSeries in Transaction 17 and then want to query that same TimeSeries. The newly inserted events may still be replicating through the Ditto mesh. Should these new events be returned in the query response? In other words, do the results of a query depend on whether or not the insertion is first applied? Transaction IDs help solve this problem.'),(0,i.kt)("p",null,"In each API Request a ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction ID")," may optionally be provided in an HTTP HEADER called ",(0,i.kt)("inlineCode",{parentName:"p"},"X-DITTO-TXN-ID"),' with an integer value, which represents this request should be applied to the "version" of the data ',(0,i.kt)("em",{parentName:"p"},"at least")," as recent as this value. Using the example above, if we inserted some events in Transaction 17, and we wanted to ensure they were included in our subsequent query, we would include the header ",(0,i.kt)("inlineCode",{parentName:"p"},"X-DITTO-TXN-ID: 17")," in our request. If we don't supply this header, the default behavior is to use the most recent version common to all Ditto nodes. Note also that if the Ditto node servicing the Request can't supply the version of the data requested, an error will be returned."),(0,i.kt)("p",null,"In the example above, we mentioned that the insertion occurred in Transaction 17, but how does the client know this? When POSTing data to Ditto, the client should include an HTTP HEADER ",(0,i.kt)("inlineCode",{parentName:"p"},"X-DITTO-CLIENT-ID: base64Encode(<u128 Actor ID>)"),", that is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Actor ID")," which can be parsed as an u128 and which has been base64 encoded. The Actor ID represents which peer in the Ditto mesh is writing to Ditto. You can ",(0,i.kt)("a",{parentName:"p",href:"#generating-an-actor-id"},"generate an Actor ID")," by concatenating the Big Endian bytes for a Site ID and the current Epoch. You should typically use the same Site ID scheme as your other SDK-based Ditto Apps and only change your Site ID when you want to indicate a new client is inserting or deleting data. If successful, the response to POST or DELETE requests will include a Transaction ID, which can be used on subsequent GET requests. This type of insertion is non-blocking and so is very performant."),(0,i.kt)("p",null,'Ditto uses "delete-wins" semantics, so in some situations the client may want to force Ditto to first read its current data and ensure another peer hasn\'t issued a concurrent DELETE request before attempting an insertion with a POST request. To do this, the client provides the HTTP HEADER ',(0,i.kt)("inlineCode",{parentName:"p"},"X-DITTO-ENSURE-INSERT: true"),"."))}l.isMDXComponent=!0}}]);