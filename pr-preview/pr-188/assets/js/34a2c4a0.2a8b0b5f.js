"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1774],{80944:function(e,n,t){var o=t(67294),r=t(79443);n.Z=function(){var e=(0,o.useContext)(r.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e}},98532:function(e,n,t){t.d(n,{p:function(){return c},Z:function(){return l}});var o=t(67294),r=JSON.parse('{"rust":{"remove-query":"let removed_ids = col_tx\\n    .find_with_args(\\"color == $args.color\\", json!({\\"color\\": \\"yellow\\"}))\\n    .remove()\\n    .unwrap();\\n\\n","evict":"let evicted_ids = collection\\n    .find_with_args(\\"$args.color == color\\", json!({\\"color\\": \\"red\\"}))\\n    .sort(vec![sort_param])\\n    .evict()\\n    .unwrap();\\n\\n","insert":"let id1 = collection\\n    .insert(json!({\\"some\\": \\"value\\"}), Some(&custom_id), false)\\n    .unwrap();\\n\\n","sync-basic":"let res = ditto.try_start_sync();\\n\\n","datamodel":"let store = ditto.store();\\nlet collection = store.collection(\\"people\\").unwrap();\\n\\n","upsert-id":"let doc_id = DocumentId::new(&\\"123abc\\".to_string()).unwrap();\\nlet person = json!({ // Person implements serde::Serialize\\n    \\"_id\\": doc_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection.upsert(person).unwrap();\\n\\n","upsert":"let person = json!({\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\nlet collection = ditto.store().collection(\\"people\\").unwrap();\\nlet id = collection.upsert(person).unwrap();\\n\\n","remove-id":"collection.find_by_id(id).remove().unwrap();\\n\\n","upsert-composite-primary-key":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet complex_id = PersonId {\\n    user_id: \\"456abc\\".to_string(),\\n    work_id: 789,\\n};\\nlet doc_id = DocumentId::new(&serde_json::json!(complex_id)).unwrap();\\nlet doc = json!({\\n    \\"_id\\": doc_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection.upsert(doc).unwrap();\\n\\n","upsert-datatypes":"collection\\n    .upsert(json!({\\n      \\"boolean\\": true,\\n      \\"string\\": \\"Hello World\\",\\n      \\"number\\": 10,\\n      \\"map\\": {\\n        \\"key\\": \\"value\\"\\n      },\\n      \\"array\\": [1,2,3],\\n      \\"null\\": null,\\n    }))\\n    .unwrap();\\n\\n","upsert-default-data":"let default_id = DocumentId::new(&\\"123abc\\".to_string()).unwrap();\\nlet data = json!({ // Person implements serde::Serialize\\n    \\"_id\\": default_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection\\n    .upsert_with_strategy(data, WriteStrategy::InsertDefaultIfAbsent)\\n    .unwrap();\\n\\n","attachment":"let store = ditto.store();\\nlet collection = store.collection(\\"foo\\")?;\\nlet attachment_file_path = images_dir.join(\\"image.png\\");\\nlet mut metadata = HashMap::new();\\nmetadata.insert(\\"some\\".to_owned(), \\"string\\".to_owned());\\nlet attachment =\\n    collection.new_attachment(attachment_file_path.to_str().unwrap(), metadata)?;\\nlet doc_id = DocumentId::new(&\\"123abc\\".to_string())?;\\nlet content = json!({\\"_id\\": doc_id, \\"some\\": \\"string\\", \\"my_attachment\\": attachment});\\nlet _ = collection.upsert(content)?;\\n// Later or on another peer ...\\nlet doc = collection.find_by_id(doc_id).exec()?;\\nlet attachment_token = doc.get::<DittoAttachmentToken>(\\"my_attachment\\")?;\\nlet (tx, rx) = channel();\\nlet m_tx = std::sync::Mutex::new(tx);\\nlet fetcher = collection.fetch_attachment(attachment_token, move |event| {\\n    // completion handler\\n    if let DittoAttachmentFetchEvent::Completed { attachment } = event {\\n        let tx = m_tx.lock().unwrap();\\n        tx.send(attachment).unwrap();\\n    }\\n})?;\\nlet fetched_attachment = rx.recv().unwrap(); // may also use an async version or other sync strategy\\nlet attachment_file_path = fetched_attachment.path();\\nstd::fs::read(attachment_file_path)?;\\n\\n","counter":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet doc_id = collection\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"owned_cars\\": 0}))\\n    .unwrap();\\n\\ncollection\\n    .find_by_id(doc_id)\\n    .update(|x| {\\n        if let Some(doc) = x {\\n            doc.replace_with_counter(&\\"owned_cars\\".to_string(), false)\\n                .unwrap();\\n            doc.increment(\\"owned_cars\\", 1.0).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","array":"let people = ditto.store().collection(\\"people\\").unwrap();\\nlet id = people\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"friends\\": []}))\\n    .unwrap();\\n\\npeople\\n    .find_by_id(id)\\n    .update(|opt_doc| {\\n        if let Some(doc) = opt_doc {\\n            doc.push(\\"friends\\", \\"Susan\\").unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","update":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet doc_id = collection\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"owned_cars\\": 0, \\"friends\\": []}))\\n    .unwrap();\\n\\ncollection\\n    .find_by_id(doc_id)\\n    .update(|opt_doc| {\\n        if let Some(doc) = opt_doc {\\n            doc.set(\\"age\\", 32).unwrap();\\n            doc.replace_with_counter(&\\"owned_cars\\".to_string(), false)\\n                .unwrap();\\n            doc.increment(\\"owned_cars\\", 1.0).unwrap();\\n            doc.push(\\"friends\\", \\"Susan\\").unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","query-basic":"collection\\n    .find(\\"favoriteBooks[0].title == \\\\\'The Great Gatsby\\\\\'\\")\\n    .exec()?;\\n\\n","query-args":"let args = json!({\\"name\\": \\"Susan\\", \\"age\\": 32});\\ncollection\\n    .find_with_args(\\"name == $args.name && arg <= $args.age\\", args)\\n    .exec()?;\\n\\n","query-sort":"let sort_param = ffi_sdk::COrderByParam {\\n    query_c_str: c!(\\"miles\\"),\\n    direction: ffi_sdk::QuerySortDirection::Ascending,\\n};\\ncollection\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .sort(vec![sort_param])\\n    .exec()?;\\n\\n","query-limit":"let sort_param = ffi_sdk::COrderByParam {\\n    query_c_str: c!(\\"rank\\"),\\n    direction: ffi_sdk::QuerySortDirection::Ascending,\\n};\\ncollection\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .sort(vec![sort_param])\\n    .limit(100)\\n    .exec()?;\\n\\n","subscribe":"let store = ditto.store(); // Ditto must have a longer lifetime than all live queries\\nlet live_query = store\\n    .collection(\\"cars\\")?\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .subscribe();\\n\\n","sync-observe":"let store = ditto.store(); // Ditto must have a longer lifetime than all live queries\\nlet (tx, rx) = channel();\\n{\\n    let live_query = store.collection(\\"cars\\")?.find(\\"color == \\\\\'red\\\\\'\\").observe(\\n        move |mut docs: Vec<BoxedDocument>, event| {\\n            match event {\\n                LiveQueryEvent::Initial { .. } => { /* handle if appropriate */ }\\n                LiveQueryEvent::Update { mut insertions, .. } => {\\n                    insertions.sort_by(|a, b| b.cmp(a));\\n                    for idx in insertions.iter() {\\n                        let doc = docs.remove(*idx);\\n                        let _ = tx.send(doc).unwrap();\\n                    }\\n                }\\n            }\\n        },\\n    )?;\\n    store\\n        .collection(\\"cars\\")?\\n        .upsert(json!({\\"color\\": \\"red\\"}))\\n        .unwrap();\\n    for doc in rx.iter() {\\n        println!(\\"New doc {:?}\\", doc);\\n    }\\n} // IMPORTANT: LiveQuery goes out of scope and is Dropped and terminated here.\\n\\n","sync-observe-local":"// Some action in your app ...\\nlet store = ditto.store();\\nstore.collection(\\"cars\\")?.upsert(json!({\\"color\\": \\"red\\"}))?;\\n// Elsewhere register handlers for data changes\\n{\\n    let live_query = store\\n        .collection(\\"cars\\")?\\n        .find(\\"color == \\\\\'red\\\\\'\\")\\n        .observe_local(move |cars, event| {\\n            println!(\\"cars {:?}, event {:?}\\", cars, event);\\n            // do something when data changes\\n            // BUT this closure must be permitted to take ownership\\n        })?;\\n    // stash your live query in something with a long lifetime\\n    // or it will be dropped\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nlet p256_der_b64: &str = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nlet app_id = AppId::from_env(\\"app\\")?;\\nlet ditto = Ditto::builder()\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| identity::SharedKey::new(ditto_root, app_id, p256_der_b64))?\\n    .with_minimum_log_level(CLogLevel::Info)\\n    .build()?;\\nditto.try_start_sync()?;\\n\\n","online-playground":"let ditto = Ditto::builder()\\n    // creates a `ditto_data` folder in the directory containing the executing process\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| {\\n        // Provided as an env var, may also be provided as hardcoded string\\n        let app_id = AppId::from_env(\\"00000000-0000-4000-0000-000000000000\\")?;\\n        let shared_token = std::env::var(\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\").unwrap();\\n        let enable_cloud_sync = true;\\n        let custom_auth_url = None;\\n        OnlinePlaygroundV2::new(\\n            ditto_root,\\n            app_id,\\n            shared_token,\\n            enable_cloud_sync,\\n            custom_auth_url,\\n        )\\n    })?\\n    .build()?;\\n\\nditto.try_start_sync()?;\\n\\n","network-remote-ditto":"let mut config = TransportConfig::new(); // empty\\n\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"135.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"185.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .websocket_urls\\n    .insert(\\"wss://example.com\\".to_string()); // Custom WS endpoint\\n\\nditto.set_transport_config(config);\\nditto.try_start_sync()?;\\n\\n","network-listen":"let mut config = TransportConfig::new(); // empty\\n\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\".to_string();\\nconfig.listen.tcp.port = 4000;\\nconfig.listen.http.enabled = false;\\n\\nditto.set_transport_config(config);\\nditto.try_start_sync()?;\\n\\n","network-multiple-transports":"let mut config = TransportConfig::new(); // empty\\n\\n// 1. Enable auto-discovery of peer to peer connections\\nconfig.enable_all_peer_to_peer(); // Auto-connect via lan and bluetooth\\n\\n// 2. Configure TCP Listener\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\".to_string();\\nconfig.listen.tcp.port = 4000;\\nconfig.listen.http.enabled = false;\\n\\n// 3. Configure explicit, hard coded connections\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"135.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .websocket_urls\\n    .insert(\\"wss://example.com\\".to_string()); // Custom WS endpoint\\n\\nditto.set_transport_config(config);\\nditto.try_start_sync()?;\\n\\n"},"objc":{"attachment":"NSBundle *testBundle = [NSBundle bundleForClass:self.class];\\nNSURL *attachmentTestImage = [testBundle URLForResource:@\\"attachment_test\\" withExtension:@\\"png\\"];\\nNSData *attachmentData = [NSData dataWithContentsOfURL:attachmentTestImage];\\n\\nNSDictionary<NSString *, NSString *> *metadata = @{@\\"name\\": @\\"my_image.png\\"};\\nDITAttachment *attachment = [collection newAttachment:attachmentTestImage.path metadata:metadata];\\n\\nDITDocumentID *docID = [collection upsert:@{@\\"some\\": @\\"string\\", @\\"my_attachment\\": attachment} error:nil];\\nDITDocument *doc = [[collection findByID:docID] exec];\\nDITAttachmentToken *attachmentToken = doc[@\\"my_attachment\\"].attachmentToken;\\n\\nDITAttachmentFetcher *fetcher = [collection fetchAttachment:attachmentToken onFetchEvent:^(DITAttachmentFetchEvent *event) {\\n    switch (event.type) {\\n        case DITAttachmentFetchEventTypeCompleted: {\\n            DITAttachmentFetchEventCompleted *completed = [event asCompleted];\\n            DITAttachment *fetchedAttachment = completed.attachment;\\n            NSData *fetchedAttachmentData = [fetchedAttachment getData:nil];\\n            XCTAssertEqualObjects(fetchedAttachmentData, attachmentData);\\n            XCTAssertEqualObjects(fetchedAttachment.metadata, metadata);\\n            [attachmentRoundtripExpectation fulfill];\\n            break;\\n        }\\n        case DITAttachmentFetchEventTypeProgress:\\n            break;\\n        default:\\n            XCTFail(@\\"Got an attachment fetch event of something other than completed or progress\\");\\n            break;\\n    }\\n}];\\n\\n\\n","counter":"[[collection find:@\\"make == \'Honda\'\\"] updateWithBlock:^(NSArray<DITMutableDocument *> *docs) {\\n    for (DITMutableDocument *doc in docs) {\\n        [doc[@\\"mileage\\"] replaceWithCounter];\\n        [doc[@\\"mileage\\"] increment:1];\\n    }\\n}];\\n\\n","datamodel":"DITCollection *collection = [store collection:@\\"people\\"];\\n\\n","upsert-id":"DITDocumentID *docId = [collection upsert:@{@\\"_id\\": @\\"123abc\\", @\\"name\\": @\\"Susan\\", @\\"age\\": @32 } error:nil];\\nNSLog(@\\"%@\\", docId); // => \\"123abc\\"\\n\\n","upsert":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"]\\n                         upsert:@{ @\\"name\\": @\\"Susan\\", @\\"age\\": @31 }\\n                         error:nil];\\n\\n","upsert-composite-primary-key":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"]\\n                upsert:@{\\n                  @\\"_id\\": @{ @\\"userId\\": @\\"456abc\\", @\\"workId\\": @789 },\\n                  @\\"name\\": @\\"John\\",\\n                  @\\"age\\": @31 }\\n                error:nil];\\nNSLog(@\\"%@\\", docID); // => \\"NSDictionary @{ @\\"userId\\": \\"456abc\\": @\\"workId\\": @789 }\\"\\n\\n","upsert-datatypes":"[[ditto.store collection:@\\"foo\\"]\\n    upsert:@{\\n        @\\"boolean\\": @true,\\n        @\\"string\\": @\\"Hello World\\",\\n        @\\"number\\": @10,\\n        @\\"map\\": @{ @\\"key\\": @\\"value\\" },\\n        @\\"array\\": @[ @1, @2, @3 ],\\n        @\\"null\\": [NSNull null]\\n    }\\n error:nil\\n];\\n\\n","upsert-default-data":"DITDocumentID *defaultDocID = [[ditto.store collection:@\\"people\\"]\\n                               upsert:@{ @\\"name\\": @\\"Susan\\", @\\"age\\": @31 }\\n                               writeStrategy: DITWriteStrategyInsertDefaultIfAbsent\\n                               error:nil];\\n\\n","query-basic":"NSArray *docs = [[[ditto.store collection:@\\"people\\"]\\n                    find:@\\"favoriteBooks[0].title == \'The Great Gatsby\'\\"] exec];\\n\\n","query-args":"NSArray *documents = [[[ditto.store collection:@\\"people\\"] find:@\\"name == $args.name && age <= $args.age\\" withArgs:@{@\\"age\\": @32, @\\"name\\": @\\"Max\\"}] exec];\\n\\n","remove-query":"NSArray<DITDocumentID *> *removedIDs = [[[ditto.store collection:@\\"people\\"]\\n                                         find:@\\"name == \'Susan\'\\"] remove];\\n\\n","remove-id":"[[[ditto.store collection:@\\"test\\"] findByID:docID] remove];\\n\\n","array":"DITDocumentID *id = [[ditto.store collection:@\\"people\\"] upsert:@{\\n    @\\"name\\": @\\"Frank\\",\\n    @\\"friends\\": @[]\\n} error:nil];\\n\\n\\nDITCollection *people = [ditto.store collection:@\\"people\\"];\\n[[people findByID:id] updateWithBlock:^(DITMutableDocument *doc) {\\n    [doc[@\\"friends\\"] push:@\\"Susan\\"];\\n}];\\n\\n","update":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"] upsert:@{\\n    @\\"name\\": @\\"Frank\\",\\n    @\\"age\\": [NSNumber numberWithInt:31],\\n    @\\"ownedCars\\": [NSNumber numberWithInt:0],\\n    @\\"friends\\": @[]\\n} error:nil];\\n\\n\\nDITCollection *collection = [ditto.store collection:@\\"people\\"];\\n[[collection findByID:docID] updateWithBlock:^(DITMutableDocument *doc) {\\n    [doc[@\\"age\\"] set:[NSNumber numberWithInt:32]];\\n    [doc[@\\"ownedCars\\"] replaceWithCounter];\\n    [doc[@\\"ownedCars\\"] increment:1];\\n    [doc[@\\"friends\\"] push:@\\"Susan\\"];\\n}];\\n\\n","query-sort":"NSArray *sortedRedCars = [[[[ditto.store collection:@\\"cars\\"]\\n                  find:@\\"color == \'red\'\\"]\\n                  sort:@\\"miles\\" direction:DITSortDirectionAscending] exec];\\n\\n","query-limit":"NSArray *sortedAndLimitedRedCars = [[[[[ditto.store collection:@\\"cars\\"]\\n                  find:@\\"color == \'red\'\\"]\\n                  sort:@\\"miles\\" direction:DITSortDirectionAscending]\\n                  limit:100] exec];\\n\\n","sync-basic":"\\n    DITDitto *ditto = [TestHelpers makeDitto];\\n\\n    NSError *error = nil;\\n    [ditto tryStartSync:&error];\\n\\n","sync-observe":"\\nDITDitto *ditto = [TestHelpers makeDitto];\\n// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"]\\n    observe:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n\\n}];\\n\\n","subscribe":"\\nDITDitto *ditto = [TestHelpers makeDitto];\\n// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"] subscribe];\\n\\n","sync-observe-local":"\\nDITDitto *ditto = [TestHelpers makeDitto];\\n// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\n\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"]\\n    observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n\\n}];\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nNSString *p256_der_b64 = @\\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDITIdentity *identity = [[DITIdentity alloc] initSharedKeyWithAppID:@\\"app\\" sharedKey:p256_der_b64 siteID:nil];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\n\\n","online-playground":"// Replace the all-zero app ID with your own app ID\\nDITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundV2WithAppID:@\\"00000000-0000-0000-0000-000000000000\\"\\n                                                                       token:@\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nNSError *error = nil;\\n[ditto tryStartSync:&error];\\n\\n","network-remote-ditto":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n[transportConfig.connect.tcpServers addObject:@\\"135.1.5.5:12345\\"];\\n[transportConfig.connect.tcpServers addObject:@\\"185.1.5.5:12345\\"];\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto tryStartSync:&err];\\n\\n","network-listen":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n[transportConfig.listen.tcp setEnabled:true];\\n[transportConfig.listen.tcp setInterfaceIp:@\\"0.0.0.0\\"];\\n[transportConfig.listen.tcp setPort:4000];\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto tryStartSync:&err];\\n\\n","network-multiple-transports":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n// 1. Enable Local Area Network Connections\\n[transportConfig enableAllPeerToPeer];\\n// 2. Listen for incoming connections on port 4000\\n[transportConfig.listen.tcp setEnabled:true];\\n[transportConfig.listen.tcp setInterfaceIp:@\\"0.0.0.0\\"];\\n[transportConfig.listen.tcp setPort:4000];\\n// 3. Connect explicitly to remote devices\\n[transportConfig.connect.tcpServers addObject:@\\"135.1.5.5:12345\\"];\\n[transportConfig.connect.tcpServers addObject:@\\"185.1.5.5:12345\\"];\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto tryStartSync:&err];\\n\\n","network-monitor-conditions":"// Setting up inside a ViewController\\nDITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundV2WithAppID:@\\"REPLACE_WITH_APP_ID\\" token:@\\"REPLACE_WITH_PLAYGROUND_TOKEN\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nditto.delegate = self;\\n[ditto tryStartSync:nil];\\n \\n// Now you can observe real time changes to the transport conditions:\\n@interface ViewController () <DITDittoDelegate>\\n\\n@end\\n\\n@implementation ViewController\\n\\n- (void)transportConditionChanged:(enum DITTransportCondition)condition forSubsystem:(enum DITConditionSource)source {\\n    if (condition == DITTransportConditionBleDisabled) {\\n        NSLog(@\\"BLE disabled\\");\\n    } else if (condition == DITTransportConditionNoBleCentralPermission) {\\n        NSLog(@\\"Permission missing for BLE\\");\\n    } else if (condition == DITTransportConditionNoBlePeripheralPermission) {\\n        NSLog(@\\"Permission missing for BLE\\");\\n    }\\n}\\n\\n@end\\n\\n","evict":"NSArray<DITDocumentID *> *evictedIDs = [[collection find:@\\"make == \'Honda\'\\"] evict];\\n\\n"},"swift":{"shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nlet p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\"\\nlet identity = DittoIdentity.sharedKey(appID: \\"app\\", sharedKey: p256DerB64)\\nDitto(identity: identity)\\n\\n","online-playground":"let ditto = Ditto(identity: DittoIdentity.onlinePlaygroundV2(\\n    // Replace the all-zero app ID with your own app ID\\n    appID: \\"00000000-0000-0000-0000-000000000000\\",\\n    token: \\"REPLACE_ME_WITH_A_SHARED_TOKEN\\")\\n)\\ntry! ditto.tryStartSync()\\n\\n","datamodel":"let carsCollection = ditto.store[\\"cars\\"]\\n// or\\nlet carsCollection = ditto.store.collection(\\"cars\\")\\n\\n","attachment":"\\nlet collection = ditto.store[\\"foo\\"]\\n\\nlet myImageURL = bundle.url(forResource: \\"image\\", withExtension: \\"png\\")!\\n\\nlet metadata = [\\"name\\": \\"my_image.png\\"]\\nlet attachment = collection.newAttachment(\\n    path: myImageURL.path,\\n    metadata: metadata\\n)!\\n\\nlet docID = try! collection.upsert([\\"some\\": \\"string\\", \\"my_attachment\\": attachment])\\n\\n// Later, find the document and the fetch the attachment\\n\\nlet doc = collection.findByID(docID).exec()\\nlet attachmentToken = doc![\\"my_attachment\\"].attachmentToken!\\n\\nlet fetcher = collection.fetchAttachment(token: attachmentToken) { status in\\n    switch status {\\n    case .completed(let fetchedAttachment):\\n        // Do something with attachment\\n        break\\n    default:\\n        print(\\"Unable to fetch attachment\\")\\n        break\\n    }\\n}\\n\\n","upsert-default-data":"let docID = try! ditto.store[\\"people\\"].upsert([\\n    \\"name\\": \\"Susan\\",\\n    \\"age\\": 31\\n], writeStrategy: .insertDefaultIfAbsent)\\n\\n","upsert-composite-primary-key":"let docID = try! ditto.store[\\"people\\"].upsert([\\n    \\"_id\\": [ \\"userId\\": \\"456abc\\", \\"workId\\": 789 ],\\n    \\"name\\": \\"Susan\\",\\n    \\"age\\": 31\\n])\\nprint(docID) // \\"[ \\"userId\\": \\"456abc\\", \\"workId\\": 789 ]\\"\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\ntry! ditto.store[\\"foo\\"].upsert([\\n    \\"boolean\\": true,\\n    \\"string\\": \\"Hello World\\",\\n    \\"number\\": 10,\\n    \\"map\\": [\\"key\\": \\"value\\"],\\n    \\"array\\": [1,2,3],\\n    \\"null\\": nil\\n])\\n\\n","counter":"let docId = try! ditto.store[\\"people\\"].upsert([\\n    \\"name\\": \\"Frank\\",\\n    \\"ownedCars\\": 0 // here 0 is a number\\n])\\n\\nditto.store[\\"people\\"].findByID(docId).update({ mutableDoc in\\n    mutableDoc?[\\"ownedCars\\"].replaceWithCounter()\\n    mutableDoc?[\\"ownedCars\\"].increment(amount: 1)\\n})\\n\\n","array":"let id = try! ditto.store[\\"people\\"].upsert([\\n    \\"name\\": \\"Frank\\",\\n    \\"friends\\": []\\n])\\n\\nditto.store[\\"people\\"].findByID(id).update({ mutableDoc in\\n    mutableDoc?[\\"friends\\"].push(\\"Susan\\")\\n})\\n\\n","update":"let docID = try! ditto.store[\\"people\\"].upsert([\\n    \\"name\\": \\"Frank\\",\\n    \\"age\\": 31,\\n    \\"ownedCars\\": 0,\\n    \\"friends\\": []\\n])\\n\\nditto.store[\\"people\\"].findByID(docID).update { mutableDoc in\\n    mutableDoc?[\\"age\\"] = 32\\n    mutableDoc?[\\"ownedCars\\"].replaceWithCounter()\\n    mutableDoc?[\\"ownedCars\\"].increment(amount: 1)\\n    mutableDoc?[\\"friends\\"].push(\\"Susan\\")\\n}\\n\\n","upsert":"// upsert JSON-compatible data into Ditto\\nlet docID = try! ditto.store[\\"people\\"].upsert([\\n    \\"name\\": \\"Susan\\",\\n    \\"age\\": 31\\n])\\n\\n","upsert-id":"// upsert JSON-compatible data into Ditto\\nlet docID = try! ditto.store[\\"people\\"].upsert([\\n    \\"_id\\": \\"abc123\\",\\n    \\"name\\": \\"Susan\\",\\n    \\"age\\": 31\\n])\\n\\n","query-basic":"let collection = ditto.store[\\"people\\"]\\n    .find(\\"favoriteBooks[0].title == \'The Great Gatsby\'\\")\\n    .exec()\\n\\n","query-args":"let documents = ditto.store[\\"users\\"].find(\\"name == $args.name && age <= $args.age\\", args: [\\n    \\"age\\": 32,\\n    \\"name\\": \\"Max\\"\\n]).exec()\\n\\n","query-sort":"let sortedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", direction: .ascending)\\n    .exec()\\n\\n","query-limit":"let sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", direction: .ascending)\\n    .limit(100)\\n    .exec()\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nfunc userDidInsertCar() {\\n    _ = try! ditto.store.collection(\\"cars\\").upsert([\\n        \\"model\\": \\"Ford\\",\\n        \\"color\\": \\"black\\"\\n    ])\\n}\\n\\n// Register live query to update UI\\nlet liveQuery = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\")\\n    .observeLocal { cars, event in\\n        // do something\\n    }\\n\\n","sync-observe":"// Register live query to update UI\\nlet example = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\")\\n   .observe { cars, event in\\n     // do something\\n}\\n\\n","subscribe":"// Register live query to update UI\\nlet subscription = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\").subscribe()\\n\\n","network-remote-ditto":"let config = DittoTransportConfig()\\n// Connect explicitly to a remote devices\\nconfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\nconfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.setTransportConfig(config: config)\\n\\ndo {\\n  try ditto.tryStartSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-listen":"let config = DittoTransportConfig()\\n\\n// Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\nconfig.listen.tcp.port = 4000\\n\\nditto.setTransportConfig(config: config)\\n\\ndo {\\n  try ditto.tryStartSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-multiple-transports":"var config = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections\\nconfig.enableAllPeerToPeer()\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\nconfig.listen.tcp.port = 4000\\n\\n// 3. Connect explicitly to remote devices\\nconfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\nconfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.setTransportConfig(config: config)\\n\\ndo {\\n  try ditto.tryStartSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-monitor-conditions":"// Setting up inside a ViewController\\nlet ditto = Ditto(identity: DittoIdentity.onlinePlaygroundV2(appID: \\"REPLACE_ME_WITH_YOUR_APP_ID\\", token: \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"))\\nditto.delegate = self\\ntry! ditto.tryStartSync()\\n\\n// Now you can observe real time changes to the transport conditions:\\nextension ViewController: DittoDelegate {\\n   func transportConditionDidChange(transportID: Int64, condition: TransportCondition) {\\n       if condition == .BleDisabled {\\n           print(\\"BLE disabled\\")\\n       } else if condition == .NoBleCentralPermission {\\n           print(\\"Permission missing for BLE\\")\\n       } else if condition == .NoBlePeripheralPermission {\\n           print(\\"Permission missing for BLE\\")\\n       }\\n   }\\n\\n\\n","evict":"collection.find(\\"owner == \'Bob\'\\").evict()\\n\\n","remove-query":"collection.find(\\"owner == \'Bob\'\\").remove()\\n\\n","remove-id":"collection.findByID(docID).remove()\\n\\n","sync-basic":"try! ditto.tryStartSync()\\n\\n"},"cpp":{"sync-observe-local":"// --- Register live query to update UI\\nstd::shared_ptr<LiveQuery> query =\\n    collection.find(\\"color == \'red\'\\")\\n        .observe_local([&](std::vector<Document> docs, LiveQueryEvent event) {\\n\\n        });\\n\\n","datamodel":"Collection cars_collection = ditto.get_store().collection(\\"cars\\");\\n\\n","upsert-id":"json person = json({{\\"_id\\", \\"123abc\\"}, {\\"name\\", \\"Susan\\"}, {\\"age\\", 31}});\\nDocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(person);\\n\\n","upsert":"json person = json({{\\"name\\", \\"Susan\\"}, {\\"age\\", 31}});\\nDocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(person);\\n\\n","upsert-composite-primary-key":"json content = json({{\\"_id\\", {{\\"userId\\", \\"456abc\\"}, {\\"workId\\", 789}}},\\n                     {\\"name\\", \\"Susan\\"},\\n                     {\\"age\\", 31}});\\nDocumentId doc_ID = ditto.get_store().collection(\\"people\\").upsert(content);\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nditto.get_store().collection(\\"foo\\").upsert(json({{\\"boolean\\", true},\\n                                                 {\\"string\\", \\"Hello World\\"},\\n                                                 {\\"number\\", 10},\\n                                                 {\\"map\\", {{\\"key\\", \\"value\\"}}},\\n                                                 {\\"array\\", {1, 2, 3}},\\n                                                 {\\"null\\", NULL}}));\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared\\n// key for every application.\\nconst std::string p256_der_b64 =\\n    \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4\\"\\n    \\"hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlq\\"\\n    \\"nfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDitto ditto = ditto::Ditto(Identity::SharedKey(\\"\\", p256_der_b64), path);\\n\\n","attachment":"auto attachment_file_path = fs::path(images_path.string() + \\"/image.png\\");\\nstd::map<std::string, std::string> metadata = {{\\"some\\", \\"string\\"}};\\n\\nAttachment attachment =\\n    collection.new_attachment(attachment_file_path.string(), metadata);\\n\\nauto doc_id =\\n    collection.upsert({{\\"some\\", \\"string\\"}, {\\"my_attachment\\", attachment}});\\n\\n// Later, find the document and the fetch the attachment\\nauto doc = collection.find_by_id(doc_id).exec();\\nauto att_token = (*doc)[\\"my_attachment\\"].get_attachment_token();\\n\\nauto fetcher = collection.fetch_attachment(\\n    att_token,\\n    AttachmentFetcherEventHandler{\\n        [&](std::unique_ptr<AttachmentFetchEvent> event) {\\n          switch (event->type) {\\n          case AttachmentFetchEventType::Completed: {\\n            AttachmentFetchEventCompleted *completed_event =\\n                static_cast<AttachmentFetchEventCompleted *>(event.get());\\n            Attachment fetched_attachment = completed_event->attachment;\\n            // Do something with attachment\\n            break;\\n          }\\n          default:\\n            std::cout << \\"Unable to fetch attachment\\" << std::endl;\\n          }\\n        }});\\n\\n","counter":"DocumentId docID = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"ownedCars\\", 0}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(docID).update(\\n    [](MutableDocument &doc) {\\n      doc[\\"ownedCars\\"].replace_with_counter();\\n      doc[\\"ownedCars\\"].increment(1);\\n    });\\n\\n","update":"DocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"age\\", 31}, {\\"ownedCars\\", 0}, {\\"friends\\", {}}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(doc_id).update(\\n    [](MutableDocument &doc) {\\n      doc[\\"age\\"].set(32);\\n      doc[\\"ownedCars\\"].replace_with_counter();\\n      doc[\\"ownedCars\\"].increment(1);\\n      doc[\\"friends\\"].push(\\"Susan\\");\\n    });\\n\\n","array":"DocumentId id = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"friends\\", {}}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(id).update(\\n    [](MutableDocument &doc) { doc[\\"friends\\"].push(\\"Susan\\"); });\\n\\n","remove-id":"ditto.get_store().collection(\\"people\\").find_by_id(doc_id).remove();\\n\\n","remove-query":"ditto.get_store().collection(\\"people\\").find(\\"age <= 32\\").remove();\\n\\n","evict":"ditto.get_store().collection(\\"people\\").find(\\"age <= 32\\").evict();\\n\\n","upsert-default-data":"DocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(\\n    content, WriteStrategy::insertDefaultIfAbsent);\\n\\n","query-basic":"std::vector<Document> results =\\n    ditto.get_store()\\n        .collection(\\"people\\")\\n        .find(\\"favoriteBooks[0].title == \'The Great Gatsby\'\\")\\n        .exec();\\n\\n","query-args":"json args = json({{\\"age\\", 32}, {\\"name\\", \\"max\\"}});\\nstd::vector<Document> big_c_values =\\n    ditto.get_store()\\n        .collection(\\"people\\")\\n        .find(\\"name == $args.name && age <= $args.age\\", args)\\n        .exec();\\n\\n","query-sort":"std::vector<Document> sorted_red_cars =\\n    ditto.get_store()\\n        .collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", SortDirection::ascending)\\n        .exec();\\n\\n","query-limit":"std::vector<Document> sorted_and_limited_red_cars =\\n    ditto.get_store()\\n        .collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", SortDirection::ascending)\\n        .limit(100)\\n        .exec();\\n\\n","sync-basic":"try {\\n  ditto.try_start_sync();\\n} catch (const DittoError &err) {\\n  std::cerr << err.what();\\n}\\n\\n","subscribe":"ditto::Subscription subscription =\\n    collection.find(\\"color == \'red\'\\").subscribe();\\n\\n","sync-observe":"std::shared_ptr<LiveQuery> liveQuery =\\n    collection.find(\\"color == \'red\'\\")\\n        .observe([&](std::vector<Document> docs, LiveQueryEvent event) {\\n          // do something\\n        });\\n\\n","online-playground":"Ditto ditto;\\nauto identity =\\n    Identity::OnlinePlaygroundV2(\\"00000000-0000-4000-0000-000000000000\\",\\n                                 \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\");\\ntry {\\n  ditto = Ditto(identity, \\"your-persistence-path\\");\\n  ditto.try_start_sync();\\n} catch (const DittoError &err) {\\n}\\n\\n","network-remote-ditto":"auto config = ditto::TransportConfig();\\n// Connect explicitly to remote devices\\nconfig.connect.tcp_servers.insert(\\"135.1.5.5:12345\\");\\nconfig.connect.tcp_servers.insert(\\"185.1.5.5:12345\\");\\n\\n// set the transport config\\nditto.set_transport_config(config);\\n// now you can start ditto\'s sync\\nditto.try_start_sync();\\n\\n","network-listen":"auto config = ditto::TransportConfig();\\n\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.http.enabled = false;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\";\\nconfig.listen.tcp.port = 4000;\\n\\nditto.set_transport_config(config);\\nditto.try_start_sync();\\n\\n","network-multiple-transports":"auto config = ditto::TransportConfig();\\n// 1. Enable All Peer to Peer Connections\\nconfig.enable_all_peer_to_peer();\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.http.enabled = false;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\";\\nconfig.listen.tcp.port = 4000;\\n\\n// 3. Connect explicitly to remote devices\\nconfig.connect.tcp_servers.insert(\\"135.1.5.5:12345\\");\\nconfig.connect.tcp_servers.insert(\\"185.1.5.5:12345\\");\\n\\nditto.set_transport_config(config);\\nditto.try_start_sync();\\n\\n"},"bash":{"upsert-composite-primary-key":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"write\\",\\n    \\"parameters\\": {\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"value\\": {\\n          \\"_id\\": { \\n            \\"user_id\\": \\"456abc\\",\\n            \\"work_id\\": 789\\n            },\\n          \\"name\\": \\"Susan\\", \\n          \\"age\\": 31\\n        }\\n      }]\\n    }\\n  }\'\\n\\n","upsert":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"write\\",\\n    \\"parameters\\": {\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\"age\\": 31\\n        }\\n      }]\\n    }\\n  }\'\\n\\n","upsert-id":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"write\\",\\n    \\"parameters\\": {\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"value\\": {\\n          \\"_id\\": \\"456abc\\",\\n          \\"name\\": \\"Susan\\", \\n          \\"age\\": 31\\n        }\\n      }]\\n    }\\n  }\'\\n\\n","upsert-datatypes":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"write\\",\\n    \\"parameters\\": {\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"value\\": {\\n          \\"_id\\": \\"456abc\\",\\n          \\"boolean\\": true, \\n          \\"string\\": \\"Hello World\\",\\n          \\"number\\": 10,\\n          \\"map\\": {\\n            \\"key\\": \\"value\\",\\n          },\\n          \\"array\\": [1,2,3],\\n          \\"null\\": null\\n        }\\n      }]\\n    }\\n  }\'\\n\\n","update":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"write\\",\\n    \\"parameters\\": {\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"value\\": {\\n          \\"_id\\": \\"123abc\\",\\n          \\"name\\": \\"Frank\\", \\n          \\"age\\": 32,\\n          \\"friends\\": [\\"Susan\\"],\\n          \\"owned_cars\\": 0\\n        }\\n      }]\\n    }\\n  }\'\\n\\n","query-basic":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n    \\"method\\": \\"find\\",\\n    \\"parameters\\": {\\n      \\"collection\\": \\"people\\",\\n      \\"query\\": \\"favoriteBooks[0].title == \'The Great Gatsby\'\\"\\n    }\\n  }\'\\n\\n","query-args":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n    \\"method\\": \\"find\\",\\n    \\"parameters\\": {\\n      \\"args\\": {\\n        \\"name\\": \\"max\\",\\n        \\"age\\": 32\\n      },\\n      \\"collection\\": \\"people\\",\\n      \\"query\\": \\"name == $args.name && age <= $args.age\\"\\n    }\\n  }\'\\n\\n","query-limit":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"find\\",\\n    \\"parameters\\": {\\n      \\"collection\\": \\"people\\",\\n      \\"query\\": \\"color == \'red\'\\",\\n      \\"limit\\": 100\\n    }\\n  }\'\\n\\n","remove-id":"curl -X DELETE \'https://<CLOUD_ENDPOINT>/api/v1/collections/people/documents/<doc_id>\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\n\\n"},"javascript":{"online-playground":"import { init, Ditto } from \\"@dittolive/ditto\\"\\n(async () => {\\n  await init() // you need to call this at least once before using any of the Ditto API\\nconst identity: Identity = { type: \'onlinePlaygroundV2\', appID: \'00000000-0000-4000-0000-000000000000\', token: \'REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\' }\\nconst ditto = new Ditto(identity, path)\\nditto.tryStartSync()\\n})()\\n\\n","datamodel":"const carsCollection = ditto.store.collection(\'cars\')\\n\\n","upsert-id":"const docId = await ditto.store.collection(\'people\').upsert({\\n  _id: \'123abc\',\\n  name: \'Susan\',\\n  age: 31,\\n})\\n\\nconsole.log(docId) // \\"123abc\\"\\n\\n","upsert":"const docId = await ditto.store.collection(\'people\').upsert({\\n  name: \'Susan\',\\n  age: 31,\\n})\\nconsole.log(docId) // \\"507f191e810c19729de860ea\\"\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nawait ditto.store.collection(\'people\').upsert({\\n  boolean: true,\\n  string: \'Hello World\',\\n  number: 10,\\n  map: { key: \'value\' },\\n  array: [],\\n  null: null,\\n})\\n\\n","counter":"const frankId = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  ownedCars: 0, // here 0 is a number\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(frankId)\\n  .update((mutableDoc) => {\\n    mutableDoc._replaceWithCounterAt(\'ownedCars\')\\n    mutableDoc._incrementCounterAt(\'ownedCars\', 1)\\n  })\\n\\n","upsert-default-data":"const docId = await ditto.store.collection(\'people\').upsert(\\n  {\\n    name: \'Susan\',\\n    age: 31,\\n  },\\n  { writeStrategy: \'insertDefaultIfAbsent\' },\\n)\\n\\n","upsert-composite-primary-key":"const docId = await ditto.store.collection(\'people\').upsert({\\n  _id: { userId: \'456abc\', workId: 789 },\\n  name: \'Susan\',\\n  age: 31,\\n})\\nconsole.log(docId) // \\"{ \\"userId\\": \\"456abc\\", \\"workId\\": 789 }\\"\\n\\n","array":"const id = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  friends: [],\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(id)\\n  .update((mutableDoc) => {\\n    mutableDoc[\'friends\'].push(\'Susan\')\\n  })\\n\\n","update":"const docID = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  age: 31,\\n  ownedCars: 0,\\n  friends: [],\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(docID)\\n  .update((mutableDoc) => {\\n    mutableDoc[\'age\'] = 32\\n    mutableDoc[\'friends\'].push(\'Susan\')\\n\\n    mutableDoc._replaceWithCounterAt(\'ownedCars\')\\n    mutableDoc._incrementCounterAt(\'ownedCars\', 1)\\n  })\\n\\n","query-basic":"const collection = await ditto.store.collection(\'people\').find(\\"favoriteBooks[0].title == \'The Great Gatsby\'\\")\\n\\n","remove-id":"await ditto.store.collection(\'people\').findByID(docId).remove()\\n\\n","query-args":"const query = \'name == $args.name && age <= $args.age\'\\nconst documents = await ditto.store.collection(\'people\').find(query, {\\n  age: 32,\\n  name: \'Max\',\\n})\\n\\n","remove-query":"await ditto.store.collection(\'people\').find(\'age <= 32\').remove()\\n\\n","query-sort":"const sortedRedCars = await ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").sort(\'miles\', \'ascending\')\\n\\n","query-limit":"const sortedAndLimitedRedCars = await ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").sort(\'miles\', \'ascending\').limit(100)\\n\\n","evict":"await ditto.store.collection(\'people\').find(\'age <= 32\').evict()\\n\\n","sync-basic":"try {\\n  ditto.tryStartSync()\\n} catch (err) {\\n  console.error(err)\\n}\\n\\n","sync-observe":"const liveQuery = ditto.store\\n  .collection(\'cars\')\\n  .find(\\"color == \'red\'\\")\\n  .observe((cars, event) => {\\n    // do something\\n  })\\n\\n","subscribe":"const subscription = ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").subscribe()\\n\\n","sync-observe-local":"const liveQuery = ditto.store\\n  .collection(\'cars\')\\n  .find(\\"color == \'red\'\\")\\n  .observeLocal((cars, event) => {\\n    // do something\\n  })\\n\\n","attachment":"const collection = ditto.store.collection(\'foo\')\\n\\nconst myImageBase64 = \'iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEW10NBjBBbqAAAAH0lEQVRoge3BAQ0AAADCoPdPbQ43oAAAAAAAAAAAvg0hAAABmmDh1QAAAABJRU5ErkJggg==\'\\nconst myImageBytes = Uint8Array.from(myImageBase64, (character) => character.charCodeAt(0))\\nconst metadata = { name: \'image.png\' }\\n\\n// On Node, you can also pass a file path (string) instead of image data\\n// and the attachment will be created from that file.\\nconst attachment = await collection.newAttachment(myImageBytes, metadata)\\n\\nconst docID = await collection.upsert({ some: \'string\', my_attachment: attachment })\\n\\n// Later, find the document and then fetch the attachment\\n\\nconst doc = await collection.findByID(docID)\\nconst attachmentToken = doc.my_attachment\\n\\nconst attachmentFetcher = collection.fetchAttachment(attachmentToken, async (attachmentFetchEvent) => {\\n  switch (attachmentFetchEvent.type) {\\n    case \'Completed\':\\n      const fetchedAttachment = attachmentFetchEvent.attachment\\n      // Do something with attachment\\n      break\\n\\n    default:\\n      console.log(\'Unable to fetch attachment\')\\n      break\\n  }\\n})\\n\\n// There is also a more convenient way of fetching the attachment\\n// (AttachmentFetcher implements the `PromiseLike` protocol):\\nconst fetchedAttachment = await collection.fetchAttachment(attachmentToken)\\n// Do something with attachment\\n\\n","network-remote-ditto":"\\n      import { TransportConfig } from \'@dittolive/ditto\'\\n\\n      const config = new TransportConfig()\\n      config.connect.websocketURLs.push(\'wss://135.1.5.5:12345\')\\n      config.connect.websocketURLs.push(\'wss://185.1.5.5:12345\')\\n      ditto.setTransportConfig(config)\\n      ditto.tryStartSync()\\n\\n\\n","network-monitor-conditions":"const transportConditionsObserver = ditto.observeTransportConditions((condition, source) => {\\n  if (condition === \'BLEDisabled\') {\\n    console.log(\'BLE disabled\')\\n  } else if (condition === \'NoBLECentralPermission\') {\\n    console.log(\'Permission missing for BLE\')\\n  } else if (condition === \'NoBLEPeripheralPermission\') {\\n    console.log(\'Permissions missing for BLE\')\\n  }\\n})\\n\\n","network-multiple-transports":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\n// 1. Enable All Peer to Peer Connections (not in a browser environment)\\nconfig.setAllPeerToPeerEnabled(true)\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \'0.0.0.0\'\\nconfig.listen.tcp.port = 4000\\n\\n// 3. Connect explicitly to remote devices\\nditto.setTransportConfig(config)\\nditto.tryStartSync()\\n\\n","network-listen":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \'0.0.0.0\'\\nconfig.listen.tcp.port = 4000\\nditto.setTransportConfig(config)\\nditto.tryStartSync()\\n\\n"},"csharp":{"sync-basic":"try\\n{\\n    onlineDitto.TryStartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    // handle exception\\n}\\n\\n","remove-query":"ditto.Store.Collection(\\"people\\").Find(\\"age <= 32\\").Remove();\\n\\n","remove-id":"var wasRemoved = coll.FindById(docID).Remove();\\n\\n","counter":"var results = coll.FindById(docID).Update(mutableDoc =>\\n{\\n    mutableDoc[\\"color\\"].Set(\\"yellow\\");\\n    mutableDoc[\\"mileage\\"].ReplaceWithCounter();\\n    mutableDoc[\\"mileage\\"].Increment(99);\\n});\\n\\n","array":"var content = new Dictionary<string, object>\\n{\\n    { \\"name\\", \\"Bob\\" },\\n    { \\"friends\\", new List<object>() }\\n};\\n\\nvar docId = ditto.Store.Collection(\\"people\\").Upsert(content);\\nditto.Store.Collection(\\"people\\").FindById(docId).Update((mutableDoc) =>\\n{\\n    mutableDoc[\\"friends\\"].Push(\\"Susan\\");\\n});\\n\\n","update":"var content = new Dictionary<string, object>\\n{\\n    { \\"name\\", \\"Bob\\" },\\n    { \\"age\\", 40 },\\n    { \\"ownedCars\\", 0 },\\n    { \\"friends\\", new List<object>() }\\n};\\n\\nvar docId = ditto.Store.Collection(\\"people\\").Upsert(content);\\nditto.Store.Collection(\\"people\\").FindById(docId).Update((mutableDoc) =>\\n{\\n    mutableDoc[\\"age\\"].Set(32);\\n    mutableDoc[\\"ownedCars\\"].ReplaceWithCounter();\\n    mutableDoc[\\"ownedCars\\"].Increment(1);\\n    mutableDoc[\\"friends\\"].Push(\\"Susan\\");\\n});\\n\\n","evict":"ditto.Store.Collection(\\"people\\").Find(\\"age <= 32\\").Evict();\\n\\n","attachment":"string attachmentImagePath = Path.Combine(Directory.GetCurrentDirectory(), \\"attachment_test.png\\");\\n\\nvar originalBytes = File.ReadAllBytes(attachmentImagePath);\\n\\nvar metadata = new Dictionary<string, string> { { \\"name\\", \\"my_image.png\\" } };\\nvar attachment = coll.NewAttachment(attachmentImagePath, metadata);\\n\\nvar docId = coll.Upsert(new Dictionary<string, object> { { \\"some\\", \\"string\\" }, { \\"my_attachment\\", attachment } });\\n\\nvar doc = coll.FindById(docId).Exec();\\nvar attachmentToken = doc[\\"my_attachment\\"].AttachmentToken;\\nusing var fetcher = coll.FetchAttachment(attachmentToken, (DittoAttachmentFetchEvent ev) =>\\n{\\n    switch (ev)\\n    {\\n        case DittoAttachmentFetchEvent.Completed e:\\n            // Do something with attachment\\n            break;\\n        default:\\n            System.Console.WriteLine($\\"Unable to fetch attachment\\");\\n            break;\\n    }\\n});\\n\\n","upsert-composite-primary-key":"// Insert JSON-compatible data into Ditto\\nvar content = new Dictionary<string, object> {\\n    { \\"_id\\", new Dictionary<string, object> {{ \\"userId\\", \\"456abc\\" }, { \\"workId\\", 789 }} },\\n    { \\"name\\", \\"Susan\\" },\\n    { \\"age\\", 31 }\\n};\\nvar docId = ditto.Store.Collection(\\"people\\").Upsert(content);\\n\\n","upsert-default-data":"// Immediately try and insert some new default data\\nvar docID = coll.Upsert(\\n    new Dictionary<string, object> { { \\"name\\", \\"Susan\\" } },\\n    DittoWriteStrategy.InsertDefaultIfAbsent);\\n\\n","datamodel":"var coll = ditto.Store.Collection(\\"people\\");\\n\\n","upsert":"var docId = ditto.Store.Collection(\\"people\\").Upsert(\\n    new Dictionary<string, object> {\\n    { \\"name\\", \\"Susan\\" },\\n    { \\"age\\", 31 },\\n    }\\n);\\n\\n","upsert-id":"var returnedId = ditto.Store.Collection(\\"people\\").Upsert(\\n    new Dictionary<string, object> {\\n        { \\"_id\\", \\"123abc\\" },\\n        { \\"name\\", \\"Joe\\" },\\n        { \\"age\\", 32 },\\n        { \\"isOnline\\", true }\\n    }\\n);\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nvar content = new Dictionary<string, object>\\n{\\n    { \\"boolean\\", true },\\n    { \\"string\\", \\"Hello World\\" },\\n    { \\"number\\", 10 },\\n    { \\"map\\", new Dictionary<string, string>{{ \\"key\\", \\"value\\"}} },\\n    { \\"array\\", new int[] {1, 2, 3} },\\n    { \\"null\\", null }\\n};\\nditto.Store.Collection(\\"foo\\").Upsert(content);\\n\\n","online-playground":"try\\n{\\n    var ditto = new Ditto(DittoIdentity.OnlinePlaygroundV2(\\"00000000-0000-4000-0000-000000000000\\", \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"));\\n    ditto.TryStartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    System.Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nstring p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nvar identity = DittoIdentity.SharedKey(\\"app\\", p256DerB64);\\nDitto ditto = new Ditto(identity);\\n\\n","query-basic":"var results = ditto.Store.Collection(\\"people\\")\\n    .Find(\\"favoriteBooks[0].title == \'The Great Gatsby\'\\")\\n    .Exec();\\n\\n","query-args":"var docs = ditto.Store\\n    .Collection(\\"users\\")\\n    .Find(\\n        \\"name == $args.name && age <= $args.age\\",\\n        new Dictionary<string, object> { { \\"name\\", \\"max\\" }, { \\"age\\", 32 } })\\n    .Exec();\\n\\n","query-sort":"var sortedCars = ditto.Store.Collection(\\"cars\\")\\n    .Find(\\"color == \'red\'\\")\\n    .Sort(\\"miles\\", direction: DittoSortDirection.Ascending)\\n    .Exec();\\n\\n","query-limit":"var sortedAndLimitedRedCars = ditto.Store.Collection(\\"cars\\")\\n    .Find(\\"color == \'red\'\\")\\n    .Sort(\\"miles\\", direction: DittoSortDirection.Ascending)\\n    .Limit(100).Exec();\\n\\n","subscribe":"// --- Register live query to update UI\\nvar subscription = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .Subscribe();\\n\\n","sync-observe":"// --- Register live query to update UI\\nvar liveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .Observe((docs, DittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n// --- Register live query to update UI\\nvar localLiveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\").ObserveLocal((docs, DittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n","sync-observe-local":"// --- Register live query to update UI\\nvar localLiveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .ObserveLocal((docs, DittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n","network-remote-ditto":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n// Connect explicitly to a remote device on \\ntransportConfig.Connect.TcpServers.Add(\\"135.1.5.5:12345\\");\\n// you can add as many TcpServers as you would like.\\ntransportConfig.Connect.TcpServers.Add(\\"185.1.5.5:4567\\");\\n// set the transport config \\nditto.SetTransportConfig(transportConfig);\\n// now you can start ditto\'s sync \\nditto.TryStartSync();\\n\\n","network-listen":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\ntransportConfig.Listen.Tcp = new DittoTcpListenConfig();\\n// By default Listen.Tcp.Enabled is false, be sure to set it to true.\\ntransportConfig.Listen.Tcp.Enabled = true;\\n// if you want to listen on localhost, most likely you will use 0.0.0.0\\n// do not use \\"localhost\\" as a string\\ntransportConfig.Listen.Tcp.InterfaceIp = \\"0.0.0.0\\";\\n// specify your port.\\ntransportConfig.Listen.Tcp.Port = 4000;\\nditto.SetTransportConfig(transportConfig);\\n\\n// now you can call `ditto.TryStartSync()` \\nditto.TryStartSync();\\n\\n","network-multiple-transports":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n\\n// 1. Enable Local Area Network Connections\\ntransportConfig.EnableAllPeerToPeer();\\n\\n// 2. Listen for incoming connections on port 4000\\ntransportConfig.Listen.Tcp.Enabled = true;\\ntransportConfig.Listen.Tcp.InterfaceIp = \\"0.0.0.0\\";\\ntransportConfig.Listen.Tcp.Port = 4000;\\n\\n// 3. Connect explicitly to remote devices\\ntransportConfig.Connect.TcpServers.Add(\\"135.1.5.5:12345\\");\\ntransportConfig.Connect.TcpServers.Add(\\"185.1.5.5:12345\\");\\n\\nditto.SetTransportConfig(transportConfig);\\n\\nditto.TryStartSync();\\n\\n"},"kotlin":{"datamodel":"val carsCollection = ditto.store[\\"cars\\"]\\n// or\\nval carsCollection = ditto.store.collection(\\"cars\\")\\n\\n","upsert-id":"val docId = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"_id\\" to \\"123abc\\",\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert":"val docID = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert-composite-primary-key":"val docId = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"_id\\" to mapOf( \\"userId\\" to \\"456abc\\", \\"workId\\" to 789),\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert-datatypes":"ditto.store[\\"foo\\"].upsert(mapOf(\\n    \\"boolean\\" to true,\\n    \\"string\\" to \\"Hello World\\",\\n    \\"number\\" to 10,\\n    \\"map\\" to mapOf(\\"key\\" to \\"value\\"),\\n    \\"array\\" to listOf(1,2,3),\\n    \\"null\\" to null\\n))\\n\\n","counter":"val docID = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"ownedCars\\" to 0\\n))\\n\\nditto.store.collection(\\"people\\").findByID(docID).update { mutableDoc ->\\n    mutableDoc!![\\"ownedCars\\"].replaceWithCounter()\\n    mutableDoc[\\"ownedCars\\"].increment(1)\\n}\\n\\n","array":"val id = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"friends\\" to emptyList<String>()\\n))\\n\\nval susanId = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Susan\\",\\n    \\"friends\\" to emptyList<String>()\\n))\\n\\nditto.store.collection(\\"people\\").findByID(id).update { mutableDoc ->\\n    mutableDoc!![\\"friends\\"].push(susanId)\\n}\\n\\n","update":"val frankId = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"age\\" to 31,\\n    \\"ownedCars\\" to 0,\\n    \\"friends\\" to emptyList<String>()\\n))\\n\\nditto.store.collection(\\"people\\").findByID(frankId).update { mutableDoc ->\\n    mutableDoc?.let {\\n        it[\\"age\\"].set(32)\\n        it[\\"ownedCars\\"].replaceWithCounter()\\n        it[\\"ownedCars\\"].increment(1)\\n        it[\\"friends\\"].push(susanId)\\n    }\\n}\\n\\n","evict":"ditto.store[\\"people\\"].find(\\"age <= 32\\").evict()\\n\\n","upsert-default-data":"val docId = ditto.store.collection(\\"people\\").upsert(mapOf(\\n    \\"name\\" to \\"Susan\\",\\n    \\"age\\" to 31\\n), DittoWriteStrategy.InsertDefaultIfAbsent)\\n\\n","query-basic":"val results = ditto.store.collection(\\"people\\")\\n    .find(\\"favoriteBooks[0].title == \'The Great Gatsby\'\\")\\n    .exec()\\n\\n","query-args":"val foundDocs = ditto.store.collection(\\"people\\")\\n    .find(\\"name == \\\\$args.name && age <= \\\\$args.age\\", mapOf(\\"name\\" to \\"max\\", \\"age\\" to 32))\\n\\n","query-sort":"val sortedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", DittoSortDirection.Ascending)\\n    .exec()\\n\\n","query-limit":"val sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", DittoSortDirection.Ascending)\\n    .limit(100)\\n    .exec()\\n\\n","sync-basic":"try {\\n    ditto.tryStartSync()\\n}\\ncatch (e: DittoError) {\\n    // handle error\\n}\\n\\n","sync-observe":"// --- Register live query to update UI\\nval liveQuery = ditto.store.collection(\\"cars\\")\\n.findAll()\\n.observe { docs, event ->\\n    // Do something...\\n}\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nfun userDidInsertCar() {\\n    ditto.store.collection(\\"cars\\").upsert(mapOf(\\n        \\"model\\" to \\"Ford\\",\\n        \\"color\\" to \\"black\\"\\n    ))\\n}\\n\\n// --- Register live query to update UI\\nval observeLocalQuery = ditto.store.collection(\\"cars\\")\\n    .findAll()\\n    .observeLocal { docs, event ->\\n    // Do something...\\n}\\n\\n","subscribe":"// --- Register live query to update UI\\nval subscription = ditto.store.collection(\\"cars\\")\\n.find(\\"color == \'red\'\\")\\n.subscribe()\\n\\n","online-playground":"try {\\n    val androidDependencies = AndroidDittoDependencies(context)\\n    val identity = DittoIdentity.OnlinePlaygroundV2(androidDependencies, appID = \\"REPLACE_ME_WITH_YOUR_APP_ID\\", token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\")\\n    val ditto = Ditto(androidDependencies, identity)\\n    ditto.tryStartSync()\\n} catch(e: DittoError) {\\n    Log.e(\\"Ditto error\\", e.message!!)\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nval p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\"\\nval androidDependencies = DefaultAndroidDittoDependencies(context)\\nval identity = DittoIdentity.SharedKey(\\"app\\", p256DerB64, null)\\nDitto(androidDependencies, identity)\\n\\n","network-remote-ditto":"val transportConfig = DittoTransportConfig();\\n\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.tryStartSync()\\n\\n","network-listen":"val transportConfig = DittoTransportConfig()\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\nditto.tryStartSync()\\n\\n","network-multiple-transports":"val transportConfig = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections\\ntransportConfig.enableAllPeerToPeer()\\n// 2. Listen for incoming connections on port 4000\\ntransportConfig.listen.tcp.enabled = true\\ntransportConfig.listen.http.enabled = false\\ntransportConfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\ntransportConfig.listen.tcp.port = 4000\\n// 3. Connect explicitly to remote devices\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.tryStartSync()\\n\\n","network-monitor-conditions":"\\n        // ... Setting up inside an Activity\\n        val androidDependencies = DefaultAndroidDittoDependencies(applicationContext)\\n        val ditto = Ditto(androidDependencies, DittoIdentity.OnlinePlaygroundV2(androidDependencies, appID = \\"REPLACE_WITH_APP_ID\\", token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"))\\n        ditto.callback = this\\n        ditto.tryStartSync()\\n\\n        // Now you can observe real time changes to the transport conditions:\\n\\n        class MainActivity : AppCompatActivity(), DittoCallback {\\n\\n            override fun transportConditionDidChange(transportId: Long, condition: TransportCondition) {\\n                var toastText: String? = null\\n                if (condition == TransportCondition.TRANSPORT_CONDITION_BLE_DISABLED) {\\n                    toastText = \\"BLE disabled\\"\\n                } else if (condition == TransportCondition.TRANSPORT_CONDITION_NO_BLE_CENTRAL_PERMISSION) {\\n                    toastText = \\"Permission missing for BLE\\"\\n                } else if (condition == TransportCondition.TRANSPORT_CONDITION_NO_BLE_PERIPHERAL_PERMISSION) {\\n                    toastText = \\"Permission missing for BLE\\"\\n                }\\n                toastText?.let {\\n                    Handler(mainLooper).post {\\n                        Toast.makeText(this, it, Toast.LENGTH_LONG).show()\\n                    }\\n                }\\n            }\\n        }\\n\\n","remove-id":"coll.findByID(docID).remove()\\n\\n","remove-query":"val removedDocIDs = coll.find(\\"make == \'Honda\'\\").remove()\\n\\n","attachment":"val image = ImageIO.read(imageFile)\\n\\nval metadata = mapOf(\\"name\\" to \\"my_image.png\\")\\nval attachment = coll.newAttachment(attachmentStream, metadata)\\nval docID = coll.upsert(mapOf(\\n    \\"some\\" to \\"string\\",\\n    \\"my_attachment\\" to attachment\\n))\\n\\nvar attachmentImage: BufferedImage? = null\\n\\ncoll.findByID(docID).exec()?.let { doc ->\\n    doc[\\"my_attachment\\"].attachmentToken?.let { token ->\\n        runBlocking {\\n            attachmentImage = suspendCoroutine { continuation ->\\n                val fetcher = coll.fetchAttachment(token) { fetchEvent ->\\n                    when (fetchEvent) {\\n                        is Completed -> {\\n                            val fetchedImage =\\n                                ImageIO.read(fetchEvent.attachment.getInputStream())\\n                            continuation.resume(fetchedImage)\\n                        }\\n                        is Progress -> {}\\n                        else -> continuation.resume(null)\\n                    }\\n                }\\n                fetcher.stop()\\n            }\\n        }\\n    }\\n}\\n\\n"},"java":{"attachment":"String attachmentPath = tempFile.getPath();\\nMap<String, String> metadata = new HashMap<>();\\nmetadata.put(\\"name\\", \\"my_image.png\\");\\nDittoAttachment attachment = coll.newAttachment(attachmentPath, metadata);\\ntempFile.delete();\\n\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"some\\", \\"string\\");\\ncontent.put(\\"my_attachment\\", attachment);\\nDittoDocumentID docID = coll.upsert(content);\\n\\nDittoDocument doc = coll.findByID(docID).exec();\\nDittoAttachmentToken attachmentToken = doc.get(\\"my_attachment\\").getAttachmentToken();\\n\\nDittoAttachmentFetcher fetcher = coll.fetchAttachment(attachmentToken, event -> {\\n    if (event.getType() == DittoAttachmentFetchEventType.Completed) {\\n        DittoAttachment att = event.asCompleted().getAttachment();\\n        BufferedImage attachmentImage;\\n        try {\\n            attachmentImage = ImageIO.read(att.getInputStream());\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n    } else if (event.getType() == DittoAttachmentFetchEventType.Progress) {\\n        // do nothing - wait for `Completed` or `Deleted`\\n    } else {\\n    }\\n});\\n\\n\\n","datamodel":"DittoCollection carsCollection = ditto.store.collection(\\"cars\\");\\n\\n","upsert-id":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"_id\\", \\"123abc\\");\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentID docId = ditto.store.collection(\\"people\\").upsert(content);\\n// docId => 123abc\\n\\n","upsert":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentID docId = ditto.store.collection(\\"people\\").upsert(content);\\n// docId => 507f191e810c19729de860ea\\n\\n","upsert-composite-primary-key":"Map<String, Object> _id = new HashMap<>();\\n_id.put(\\"userId\\", \\"456abc\\");\\n_id.put(\\"workId\\", 789);\\n\\nMap<String, Object> value = new HashMap<>();\\nvalue.put(\\"_id\\", _id);\\nvalue.put(\\"name\\", \\"Susan\\");\\nvalue.put(\\"age\\", 31);\\nDittoDocumentID docID = ditto.store.collection(\\"people\\").upsert(value);\\n// docId=> \\"_id.put(\\"userId\\", \\"456abc\\"); _id.put(\\"workId\\", 789);\\"\\n\\n","remove-id":"ditto.store.collection(\\"people\\").findByID(docId).remove();\\n\\n","remove-query":"ditto.store.collection(\\"people\\").find(\\"age <= 32\\").remove();\\n\\n","evict":"ditto.store.collection(\\"people\\").find(\\"age <= 32\\").evict();\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"boolean\\", true);\\ncontent.put(\\"string\\", \\"Hello World\\");\\ncontent.put(\\"number\\", 10);\\nMap<String, String> innerMap = new HashMap<>();\\ninnerMap.put(\\"key\\", \\"value\\");\\ncontent.put(\\"map\\", innerMap);\\ncontent.put(\\"array\\", Arrays.asList(1, 2, 3));\\ncontent.put(\\"null\\", null);\\nditto.store.collection(\\"foo\\").upsert(content);\\n\\n","counter":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Frank\\");\\ncontent.put(\\"ownedCars\\", 0);\\nDittoDocumentID docID = ditto.store.collection(\\"people\\").upsert(content);\\n\\nditto.store.collection(\\"people\\").findByID(docID).update(mutDoc -> {\\n    try {\\n        mutDoc.get(\\"ownedCars\\").replaceWithCounter();\\n        mutDoc.get(\\"ownedCars\\").increment(1);\\n    } catch (DittoError err) {\\n        // Do something with error\\n    }\\n});\\n\\n","array":"Map<String, Object> frank = new HashMap<>();\\nfrank.put(\\"name\\", \\"Frank\\");\\nfrank.put(\\"friends\\", Arrays.asList());\\nDittoDocumentID frankId = ditto.store.collection(\\"people\\").upsert(frank);\\n\\nditto.store.collection(\\"people\\").findByID(frankId).update(doc -> {\\n    try {\\n        doc.get(\\"age\\").set(32);\\n        doc.get(\\"cars\\").push(\\"Ford\\");\\n    } catch (DittoError err) {\\n        // Do something with error\\n    }\\n});\\n\\n","update":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Frank\\");\\ncontent.put(\\"age\\", 31);\\ncontent.put(\\"ownedCars\\", 0);\\ncontent.put(\\"friends\\", Arrays.asList());\\nDittoDocumentID docId = ditto.store.collection(\\"people\\").upsert(content);\\n\\nditto.store.collection(\\"people\\").findByID(docId).update(doc -> {\\n    try {\\n    doc.get(\\"age\\").set(32);\\n    doc.get(\\"ownedCars\\").replaceWithCounter();\\n    doc.get(\\"ownedCars\\").increment(1);\\n    doc.get(\\"friends\\").push(\\"Susan\\");\\n    } catch (DittoError err) {\\n        // Do something with error\\n    }\\n});\\n\\n","upsert-default-data":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentID docId = ditto.store\\n        .collection(\\"people\\")\\n        .upsert(content, DittoWriteStrategy.InsertDefaultIfAbsent);\\n\\n","query-basic":"List<DittoDocument> results = ditto.store.collection(\\"people\\")\\n        .find(\\"favoriteBooks[0].title == \'The Great Gatsby\'\\")\\n        .exec();\\n\\n","query-args":"Map<String, Object> queryArgs = new HashMap<>();\\nqueryArgs.put(\\"name\\", \\"max\\");\\nqueryArgs.put(\\"age\\", 32);\\n\\nList<DittoDocument> foundDocs = ditto.store.collection(\\"users\\")\\n        .find(\\"name == $args.name && age <= $args.age\\", queryArgs)\\n        .exec();\\n\\n","query-sort":"List<DittoDocument> sortedRedCars = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", DittoSortDirection.Ascending)\\n        .exec();\\n\\n","query-limit":"List<DittoDocument> sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", DittoSortDirection.Ascending)\\n        .limit(100)\\n        .exec();\\n\\n","sync-basic":"try {\\n    ditto.tryStartSync();\\n} catch(DittoError e) {\\n    // handle error\\n}\\n\\n","sync-observe":"// --- Register live query to update UI\\nDittoLiveQuery liveQuery = ditto.store.collection(\\"cars\\")\\n        .findAll()\\n        .observe((docs, event) -> {\\n            // Do something...\\n        });\\n\\n","subscribe":"// --- Register live query to update UI\\nDittoSubscription subscription = ditto.store.collection(\\"cars\\")\\n        .findAll()\\n        .subscribe();\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"model\\", \\"Ford\\");\\ncontent.put(\\"color\\", \\"black\\");\\nditto.store.collection(\\"cars\\").upsert(content);\\n\\n// --- Register live query to update UI\\nDittoLiveQuery liveQueryLocal = ditto.store.collection(\\"cars\\")\\n        .findAll()\\n        .observeLocal((docs, event) -> {\\n            // Do something...\\n        });\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nString p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDefaultAndroidDittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);\\nDittoIdentity identity = new DittoIdentity.SharedKey(androidDependencies, \\"app\\", p256DerB64);\\nDitto ditto = new Ditto(androidDependencies, identity);\\n\\n","online-playground":"DittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);\\nDittoIdentity identity = new DittoIdentity.OnlinePlayground(androidDependencies, \\"00000000-0000-4000-0000-000000000000\\");\\nDitto ditto = new Ditto(androidDependencies, identity);\\n\\ntry {\\n    ditto.tryStartSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","network-remote-ditto":"DittoTransportConfig config = new DittoTransportConfig();\\nDittoConnect connect = new DittoConnect();\\nconnect.setTcpServers(Sets.newHashSet(\\"135.1.5.5:12345\\", \\"185.1.5.5:12345\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.tryStartSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-listen":"DittoTransportConfig config = new DittoTransportConfig();\\nconfig.enableAllPeerToPeer();\\n\\nDittoListen listen = new DittoListen();\\nDittoTcpListenConfig tcpListenConfig = new DittoTcpListenConfig();\\ntcpListenConfig.setEnabled(true);\\ntcpListenConfig.setInterfaceIp(\\"0.0.0.0\\");\\ntcpListenConfig.setPort(4000);\\nlisten.setTcp(tcpListenConfig);\\nconfig.setListen(listen);\\n\\ntry {\\n    ditto.tryStartSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-multiple-transports":"DittoTransportConfig config = new DittoTransportConfig();\\n\\n// 1. Enable Peer to Peer Connections\\nconfig.enableAllPeerToPeer();\\n\\n// 2. Listen for incoming connections on port 4000\\nDittoListen listen = new DittoListen();\\nDittoTcpListenConfig tcpListenConfig = new DittoTcpListenConfig();\\ntcpListenConfig.setEnabled(true);\\ntcpListenConfig.setInterfaceIp(\\"0.0.0.0\\");\\ntcpListenConfig.setPort(4000);\\nlisten.setTcp(tcpListenConfig);\\nconfig.setListen(listen);\\n// 3. Connect explicitly to remote devices\\nDittoConnect connect = new DittoConnect();\\nconnect.setTcpServers(Sets.newHashSet(\\"135.1.5.5:12345\\", \\"185.1.5.5:12345\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.tryStartSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-monitor-conditions":"// Setting up inside an Activity\\nDefaultAndroidDittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(getApplicationContext());\\nDitto ditto = new Ditto(androidDependencies, new DittoIdentity.OnlinePlayground(androidDependenciesOne, \\"REPLACE_WITH_APP_ID\\"));\\nditto.callback = this;\\nditto.tryStartSync();\\n\\n// Now you can observe real time changes to the transport conditions:\\npublic class MainActivity extends AppCompatActivity implements DittoCallback {\\n    @Override\\n    public void transportConditionDidChange(@NotNull DittoTransportCondition condition, @NotNull DittoConditionSource transportId) {\\n        String toastText = null;\\n        if (condition == DittoTransportCondition.BleDisabled) {\\n            toastText = \\"BLE disabled\\";\\n        } else if (condition == DittoTransportCondition.NoBleCentralPermission) {\\n            toastText = \\"Permission missing for BLE\\";\\n        } else if (condition == DittoTransportCondition.NoBlePeripheralPermission) {\\n            toastText = \\"Permission missing for BLE\\";\\n        }\\n\\n        if (toastText != null) {\\n            String finalToastText = toastText;\\n            runOnUiThread(new Runnable() {\\n                @Override\\n                public void run() {\\n                    Toast.makeText(MainActivity.this, finalToastText, Toast.LENGTH_LONG).show();\\n                }\\n            });\\n        }\\n    }\\n}\\n\\n"}}'),a=t(99013),i=t(49366),s=t(30547);function c(e){var n,t=e.name,i=e.language,s=e.label,c=r[i];if(c){var l=c[t];l&&(n=l)}return n?o.createElement(a.Z,{className:i},n.trim().replace("00000000-0000-4000-0000-000000000000","REPLACE_ME_WITH_YOUR_APP_ID")):(console.error("no snippet for "+t+" in language="+i),o.createElement("div",null,"Not supported by ",s,"."))}function l(e){e.children;var n=e.name,t=[{label:"JavaScript",value:"javascript"},{label:"Swift",value:"swift"},{label:"Objective-C",value:"objc"},{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"},{label:"C#",value:"csharp"},{label:"C++",value:"cpp"},{label:"Rust",value:"rust"},{label:"HTTP",value:"bash"}];return o.createElement(i.Z,{groupId:"programming-language",defaultValue:"javascript",values:t},t.map((function(e){return o.createElement(s.Z,{value:e.value},o.createElement(c,{name:n,language:e.value,label:e.label}))})))}},99013:function(e,n,t){t.d(n,{Z:function(){return _}});var o=t(87462),r=t(67294),a=t(86010),i=t(23746),s=t(10195),c=t(87594),l=t.n(c),d=t(95999),p=t(67804),u=t(71418),m="codeBlockContainer_2gih",g="codeBlockContent_3z4W",h="codeBlockTitle_1Kb7",f="codeBlock_6upA",y="copyButton_2e3i",D="codeBlockLines_xlV7",v=t(60370),b=/{([\d,-]+)}/,A=["js","jsBlock","jsx","python","html"],I={js:{start:"\\/\\/",end:""},jsBlock:{start:"\\/\\*",end:"\\*\\/"},jsx:{start:"\\{\\s*\\/\\*",end:"\\*\\/\\s*\\}"},python:{start:"#",end:""},html:{start:"\x3c!--",end:"--\x3e"}},w=["highlight-next-line","highlight-start","highlight-end"],k=function(e){void 0===e&&(e=A);var n=e.map((function(e){var n=I[e],t=n.start,o=n.end;return"(?:"+t+"\\s*("+w.join("|")+")\\s*"+o+")"})).join("|");return new RegExp("^\\s*(?:"+n+")\\s*$")};function _(e){var n=e.children,t=e.className,c=e.metastring,A=e.title,I=(0,v.LU)().prism,w=(0,r.useState)(!1),_=w[0],C=w[1],T=(0,r.useState)(!1),S=T[0],N=T[1];(0,r.useEffect)((function(){N(!0)}),[]);var E=(0,v.bc)(c)||A,L=(0,r.useRef)(null),x=[],P=Array.isArray(n)?n.join(""):n;if(c&&b.test(c)){var O=c.match(b)[1];x=l()(O).filter((function(e){return e>0}))}var B=null==t?void 0:t.replace(/language-/,"");!B&&I.defaultLanguage&&(B=I.defaultLanguage);var j=P.replace(/\n$/,"");if(0===x.length&&void 0!==B){for(var R,M="",U=function(e){switch(e){case"js":case"javascript":case"ts":case"typescript":return k(["js","jsBlock"]);case"jsx":case"tsx":return k(["js","jsBlock","jsx"]);case"html":return k(["js","jsBlock","html"]);case"python":case"py":return k(["python"]);default:return k()}}(B),q=P.replace(/\n$/,"").split("\n"),G=0;G<q.length;){var H=G+1,F=q[G].match(U);if(null!==F){switch(F.slice(1).reduce((function(e,n){return e||n}),void 0)){case"highlight-next-line":M+=H+",";break;case"highlight-start":R=H;break;case"highlight-end":M+=R+"-"+(H-1)+","}q.splice(G,1)}else G+=1}x=l()(M),j=q.join("\n")}var Q=function(){(0,s.Z)(j),C(!0),setTimeout((function(){return C(!1)}),2e3)};return r.createElement(i.ZP,(0,o.Z)({},i.lG,{key:String(S),theme:u.Z,code:j,language:B}),(function(e){var n=e.className,t=e.style,i=e.tokens,s=e.getLineProps,c=e.getTokenProps;return r.createElement("div",{className:m},E&&r.createElement("div",{style:t,className:h},E),r.createElement("div",{className:(0,a.Z)(g,B)},r.createElement("pre",{tabIndex:0,className:(0,a.Z)(n,f,"thin-scrollbar")},r.createElement("code",{className:D},i.map((function(e,n){1===e.length&&""===e[0].content&&(e[0].content="\n");var t=s({line:e,key:n}),i=x.includes(n+1);x.includes(n+1)&&(t.className+="bg-gray-800 docusaurus-highlight-code-line");var l=(0,a.Z)(t.className,i&&"bg-gray-700");return r.createElement("span",(0,o.Z)({key:n},t,{className:l}),e.map((function(e,n){var t=Object.assign({},c({token:e,key:n})),i=t.className;return i.includes("inserted-sign")&&(i=(0,a.Z)(i,"bg-green-900")),i.includes("deleted-sign")&&(i=(0,a.Z)(i,"bg-red-900")),r.createElement("span",(0,o.Z)({key:n},t,{className:i}))})))})))),r.createElement("button",{ref:L,type:"button","aria-label":(0,d.I)({id:"theme.CodeBlock.copyButtonAriaLabel",message:"Copy code to clipboard",description:"The ARIA label for copy code blocks button"}),className:(0,a.Z)(y,"clean-btn",_?"bg-green-500":""),onClick:Q},_?r.createElement("div",null,r.createElement(p.C2q,{className:"w-4 h-4 inline mr-1"}),r.createElement("span",{className:"text-xs"},"Copied")):r.createElement("div",null,r.createElement(p.Kmg,{className:"w-4 h-4 inline mr-1"}),r.createElement("span",{className:"text-xs"},"Copy")))))}))}},30547:function(e,n,t){var o=t(67294);n.Z=function(e){var n=e.children,t=e.hidden,r=e.className;return o.createElement("div",{role:"tabpanel",hidden:t,className:r},n)}},49366:function(e,n,t){var o=t(67294),r=t(80944),a=t(86010);n.Z=function(e){var n,t=e.lazy,i=(e.block,e.defaultValue),s=e.values,c=e.groupId,l=(e.className,o.Children.toArray(e.children)),d=null!=s?s:l.map((function(e){return{value:e.props.value,label:e.props.label}})),p=null!=i?i:null==(n=l.find((function(e){return e.props.default})))?void 0:n.props.value,u=(0,r.Z)(),m=u.tabGroupChoices,g=u.setTabGroupChoices,h=(0,o.useState)(p),f=h[0],y=h[1];if(null!=c){var D=m[c];null!=D&&D!==f&&d.some((function(e){return e.value===D}))&&y(D)}var v=function(e){y(e),null!=c&&g(c,e)};return o.createElement("div",{className:"tabs-container"},o.createElement("div",{className:"sm:hidden"},o.createElement("label",{htmlFor:"tabs",className:"sr-only"},"Select a tab"),o.createElement("select",{id:"tabs",name:"tabs",value:f,onChange:function(e){return v(e.currentTarget.value)},className:"block w-full focus:ring-blue-500 focus:border-blue-500 border-gray-300 rounded-md"},d.map((function(e){var n=e.value,t=e.label;return o.createElement("option",{value:n,key:n},null!=t?t:n)})))),o.createElement("div",{className:"hidden sm:block"},o.createElement("nav",{className:"flex space-x-4","aria-label":"Tabs"},d.map((function(e){var n=e.value,t=e.label;return o.createElement("button",{key:n,onClick:function(){return v(n)},className:(0,a.Z)(f===n?"bg-blue-100 text-blue-700":"text-gray-500 hover:text-gray-700","px-3 py-2 font-medium text-sm rounded-md"),"aria-current":f===n?"page":void 0},null!=t?t:n)})))),t?(0,o.cloneElement)(l.filter((function(e){return e.props.value===f}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},l.map((function(e,n){return(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==f})}))))}},21950:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return c},metadata:function(){return d},toc:function(){return p}});var o=t(87462),r=t(63366),a=(t(67294),t(3905)),i=(t(49366),t(30547),t(98532)),s=["components"],c={title:"Replicated Growable Array",sidebar_position:3},l=void 0,d={unversionedId:"datamodel/array",id:"datamodel/array",isDocsHomePage:!1,title:"Replicated Growable Array",description:"You might want to use a Map instead",source:"@site/docs/datamodel/array.mdx",sourceDirName:"datamodel",slug:"/datamodel/array",permalink:"/pr-preview/pr-188/datamodel/array",editUrl:"https://github.com/getditto/docs/edit/master/docs/datamodel/array.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Replicated Growable Array",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Map",permalink:"/pr-preview/pr-188/datamodel/map"},next:{title:"Attachment",permalink:"/pr-preview/pr-188/datamodel/attachment"}},p=[{value:"When do I use an array?",id:"when-do-i-use-an-array",children:[{value:"Text editing",id:"text-editing",children:[],level:3},{value:"Immutable Logs",id:"immutable-logs",children:[],level:3},{value:"Mutable Items",id:"mutable-items",children:[],level:3}],level:2},{value:"Querying",id:"querying",children:[],level:2},{value:"How it works",id:"how-it-works",children:[],level:2}],u={toc:p};function m(e){var n=e.components,t=(0,r.Z)(e,s);return(0,a.kt)("wrapper",(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("h3",{parentName:"div",id:"you-might-want-to-use-a-map-instead"},"You might want to use a Map instead"),(0,a.kt)("p",{parentName:"div"},"Ditto is a distributed database. Distributed databases work really well with\nstable ids. Arrays are really challenging to use, because items are referenced\nby their index. Indexes can change, which means indexes are not stable\nidentifiers. Two peers can see different values for the same index."),(0,a.kt)("p",{parentName:"div"},"If you're having trouble with duplicate data, you may want to use a ",(0,a.kt)("a",{parentName:"p",href:"/datamodel/map"},"map")," instead. "))),(0,a.kt)("p",null,"Arrays are an ordered list of values. Arrays can contain all primitive\nvalues as well as nested collection types like other Arrays or Maps."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Push - upserts a value on to the end of an array "),(0,a.kt)("li",{parentName:"ul"},"Pop - removes a value at the end of an array")),(0,a.kt)(i.Z,{name:"array",mdxType:"SnippetGroup"}),(0,a.kt)("p",null,"If two devices ",(0,a.kt)("inlineCode",{parentName:"p"},"push")," this data, both devices will see ",(0,a.kt)("inlineCode",{parentName:"p"},'["Susan", "Susan"]'),"."),(0,a.kt)("h2",{id:"when-do-i-use-an-array"},"When do I use an array?"),(0,a.kt)("h3",{id:"text-editing"},"Text editing"),(0,a.kt)("p",null,"For example, if two users are editing the same text box at the same time (or\nconcurrently), an array will automatically converge their edits into a single,\ncohesive list of characters."),(0,a.kt)("p",null,"Device A:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"collection.upsert({\n  id: 'abc123',\n  text: ['i', ' ', 'l', 'o', 'v', 'e', ' ', 's', 'u', 's', 'h', 'i']\n})\n")),(0,a.kt)("p",null,"Device B:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"collection.upsert({\n  id: 'abc123',\n  text: ['i', ' ', 'l', 'o', 'v', 'e', ' ', 's', 'u', 's', 'h', 'i']\n})\n")),(0,a.kt)("p",null,"When these two devices synchronize, you will see the following document:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "id": "abc123",\n  "text": "i love sushii love sushi"\n}\n')),(0,a.kt)("p",null,"You'd expect this result from a collaborative text editor; if two users type\ninto the same document textbox at the same time, you would want to preserve the\nintent of the user and render all typed characters. "),(0,a.kt)("p",null,"For inserting characters and removing characters from an index in an array, see\nthe API reference for your language. "),(0,a.kt)("h3",{id:"immutable-logs"},"Immutable Logs"),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"If you're looking to create many documents to model a timeseries, do not\nuse arrays. Instead, see the ",(0,a.kt)("a",{parentName:"p",href:"/guides/http"},"Timeseries API"),"."))),(0,a.kt)("p",null,"You can also use the array for recording a log of immutable items within a\ndocument. For example, you might want to use an array like this for reporting\nerrors about a particular document that isn't relevant for other documents\nwithin a collection."),(0,a.kt)("p",null,"Device A:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"collection.upsert({\n  id: 'abc123',\n  log: []\n})\n")),(0,a.kt)("p",null,"You can use ",(0,a.kt)("inlineCode",{parentName:"p"},"push")," to append new entries to the end of the list. This will be\nconsistent for all devices. "),(0,a.kt)("p",null,"Device A:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"collection.update(doc => {\n  doc.log.push({\n    time: '2:00pm', // your language's built-in date time library\n    error: 'First error',\n    deviceId: \"device1\"\n  })\n}\n")),(0,a.kt)("p",null,"Device B:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"collection.update(doc => {\n  doc.log.push({\n    time: '2:05pm', // your language's built-in date time library\n    error: 'Another error',\n    deviceId: \"device2\"\n  })\n}\n")),(0,a.kt)("p",null,"Concurrent ",(0,a.kt)("inlineCode",{parentName:"p"},"push")," operations will be merged into a single ordered list. The\norder between two concurrent ",(0,a.kt)("inlineCode",{parentName:"p"},"push")," operations is deterministic after\nsyncronization, which means all devices will see the same order. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "id": "abc123",\n  "log": [\n    {\n      "time": "2:05pm",\n      "error": "Another error",\n      "deviceId": "device2"\n    },\n    {\n      "time": "2:00pm",\n      "error": "First error",\n      "deviceId": "device1"\n    }\n  ]\n}\n')),(0,a.kt)("p",null,"Note that all these items could be out of order, depending on if devices are\ncalling ",(0,a.kt)("inlineCode",{parentName:"p"},"push")," while connected or disconnected from each other. "),(0,a.kt)("h3",{id:"mutable-items"},"Mutable Items"),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"Putting objects into an array is an advanced feature and should be avoided\nunless you really know what you're doing. We recommend that you use register\nvalues inside an array."))),(0,a.kt)("p",null,"If you are still convinced that you need an array, but it isn't for text editing\nor immutable items, ",(0,a.kt)("strong",{parentName:"p"},"it is still probably better use a Map instead"),"."),(0,a.kt)("p",null,"Use these rules of thumb to prevent unexpected behavior in your application:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Use ",(0,a.kt)("inlineCode",{parentName:"strong"},"upsert")," to initialize the array.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'let susanId = people.upsert({\n  name: "Susan",\n  friends: []\n})\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Use the ",(0,a.kt)("inlineCode",{parentName:"strong"},"update")," API to modify the array")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'people.update(doc => {\n  doc.friends.push("John")\n})\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Reference objects by their id")),(0,a.kt)("p",null,"This means that that objects can be modified concurrently. Otherwise, updates could be\nlost or duplicated with concurrent ",(0,a.kt)("inlineCode",{parentName:"p"},"push")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"pop")," operations."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'let johnId = people.upsert({\n  name: "John",\n  friends: []\n})\npeople.findById(susanId).update(doc => {\n  doc.friends.push(johnId)\n})\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Watch out for duplicates")),(0,a.kt)("p",null,"You may want to ignore duplicate items with the same ID by turning your arrays into Sets within application code."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"let susan = people.findById(susanId)\nlet unique = Set(susan.friends)\nrender(unqiue)\n")),(0,a.kt)("h2",{id:"querying"},"Querying"),(0,a.kt)("p",null,"For the following examples assume a document structure like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "_id": "123abc",\n  "books": [\n    {\n      "title": "Harry Potter",\n      "authors": ["J. K. Rowling"]\n    },\n    {\n      "title": "Lord of the Rings",\n      "authors": ["J. R. R. Tolkien"]\n    },\n    {\n      "title": "Game of Thrones",\n      "authors": ["George R. R. Martin"]\n    },\n    {\n      "title": "The Talisman",\n      "authors": ["Stephen King", "Peter Straub"]\n    }\n  ],\n  "tags": ["fantasy", "novel"],\n  "scores": [12, 14]\n}\n')),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"array[index]")," to access a specific index of an array property. Let's say we have a document that looks like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// finds the first book property under "books" and checks for the "title" property\nfind("books[0].title == \'Harry Potter\'")\n')),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"length(propertyPath)")," to return an integer value that represents the size of the array"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// finds books that have at least 2 tags\nfind("length(tags) >= 2")\n')),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"sum(propertyPath)")," to return a summation float that represents the sum of the array values"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// finds documents who have a sum of all their scores to be less than 10\nfind("sum(scores) < 10")\n')),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"array[? expression]")," to return an array containing only the input array items that satisfy the expression."),(0,a.kt)("p",null,"Eg. ",(0,a.kt)("inlineCode",{parentName:"p"},"books[? length(authors) >= 2]")," for the example document is ",(0,a.kt)("inlineCode",{parentName:"p"},'[{"title": "The Talisman", "authors": ["Stephen King", "Peter Straub"]}]'),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// finds documents with books that have 2 or more authors\nfind("books[? length(authors) >= 2] != []")\n')),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"array[*].subpath")," to collect a subpath of each input array item in the result array."),(0,a.kt)("p",null,"Eg. ",(0,a.kt)("inlineCode",{parentName:"p"},"books[*].authors[0]")," for the example document is ",(0,a.kt)("inlineCode",{parentName:"p"},'["J. K. Rowling", "J. R. R. Tolkien", "George R. R. Martin", "Stephen King"]')),(0,a.kt)("p",null,"Eg. ",(0,a.kt)("inlineCode",{parentName:"p"},"books[*].authors")," for the example document is ",(0,a.kt)("inlineCode",{parentName:"p"},'[["J. K. Rowling"], ["J. R. R. Tolkien"], ["George R. R. Martin"], ["Stephen King", "Peter Straub"]]')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// finds documents with books whose first author is Stephen King \nfind(\"contains('Stephen King', books[*].authors[0])\")\n")),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"array[]")," to flatten the input array by one level. Elements of the input array that are not arrays are pushed as-is to the result array."),(0,a.kt)("p",null,"Eg. ",(0,a.kt)("inlineCode",{parentName:"p"},"(books[*].authors)[]")," for the example document is ",(0,a.kt)("inlineCode",{parentName:"p"},'["J. K. Rowling", "J. R. R. Tolkien", "George R. R. Martin", "Stephen King", "Peter Straub"]')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// finds documents with books authored or co-authored by Stephen King\nfind(\"contains('Stephen King', (books[*].authors)[])\")\n")),(0,a.kt)("h2",{id:"how-it-works"},"How it works"),(0,a.kt)("p",null,"Elements are added to the array at a position. Where two element are inserted at\nposition four, after items ",(0,a.kt)("inlineCode",{parentName:"p"},"X"),", the merge will use causal information from\nthe logical clock to decide which element gets the position, and which gets the\nposition + 1. The result is deterministic."),(0,a.kt)("p",null,"When elements of an array are updated, then the element merges as-per the merge\nbehaviour of the type at that position in the array."),(0,a.kt)("p",null,"Merging works in such a way that we never merge the element with a different\nelement, even if it moves. If some element's position has changed (due to\ninsertions or removes) at one device, we ensure to merge that element with it's\ncorresponding version in the other devices."),(0,a.kt)("p",null,"When an element is removed from the array, a tombstone is recorded, ensuring\nthat if there is an update concurrent with the remove the remove wins."),(0,a.kt)("p",null,"Read more about ",(0,a.kt)("a",{parentName:"p",href:"/how-it-works/crdt"},"how Ditto's CRDT works"),"."))}m.isMDXComponent=!0}}]);